//! # Random Team Loader
//!
//! This module provides functionality to load and sample random battle teams
//! from JSON files generated by our ps-data-extractor tool.

use crate::core::battle_format::BattleFormat;
use crate::core::move_choice::PokemonType;
use crate::core::state::{Gender, Pokemon};
use crate::data::types::{Nature, Stats};
use rand::rngs::StdRng;
use rand::seq::SliceRandom;
use rand::SeedableRng;
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;

/// Represents a Pokemon set from random battle data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RandomPokemonSet {
    pub name: String,
    pub species: String,
    pub level: u8,
    pub gender: Option<String>,
    pub shiny: Option<bool>,
    pub ability: Option<String>,
    pub item: Option<String>,
    pub moves: Vec<String>,
    pub nature: Option<String>,
    pub evs: Option<RandomStats>,
    pub ivs: Option<RandomStats>,
    #[serde(rename = "teraType")]
    pub tera_type: Option<String>,
    pub role: Option<String>,
    pub gigantamax: Option<bool>,
}

/// Stats structure for EVs/IVs from random battle data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RandomStats {
    pub hp: Option<u8>,
    pub atk: Option<u8>,
    pub def: Option<u8>,
    pub spa: Option<u8>,
    pub spd: Option<u8>,
    pub spe: Option<u8>,
}

impl RandomStats {
    /// Convert to our internal Stats type with defaults
    pub fn to_stats(&self, default_value: u8) -> Stats {
        Stats {
            hp: self.hp.unwrap_or(default_value) as i16,
            attack: self.atk.unwrap_or(default_value) as i16,
            defense: self.def.unwrap_or(default_value) as i16,
            special_attack: self.spa.unwrap_or(default_value) as i16,
            special_defense: self.spd.unwrap_or(default_value) as i16,
            speed: self.spe.unwrap_or(default_value) as i16,
        }
    }
}

/// A complete random battle team (6 Pokemon)
pub type RandomTeam = Vec<RandomPokemonSet>;

/// Random team loader that manages loading and sampling teams
#[derive(Debug)]
pub struct RandomTeamLoader {
    teams_cache: std::collections::HashMap<String, Vec<RandomTeam>>,
    rng: StdRng,
}

impl RandomTeamLoader {
    /// Create a new random team loader
    pub fn new() -> Self {
        Self {
            teams_cache: std::collections::HashMap::new(),
            rng: StdRng::from_entropy(),
        }
    }

    /// Create a new random team loader with a specific seed for deterministic results
    pub fn with_seed(seed: u64) -> Self {
        Self {
            teams_cache: std::collections::HashMap::new(),
            rng: StdRng::seed_from_u64(seed),
        }
    }

    /// Load teams for a specific format
    pub fn load_teams(&mut self, format: &BattleFormat) -> Result<(), String> {
        let format_key = self.format_to_file_key(format);

        // Check if already loaded
        if self.teams_cache.contains_key(&format_key) {
            return Ok(());
        }

        let file_path = format!("data/random-teams/{}-teams.json", format_key);

        if !Path::new(&file_path).exists() {
            return Err(format!(
                "Team file not found: {}. Run team generation first.",
                file_path
            ));
        }

        let file_content = fs::read_to_string(&file_path)
            .map_err(|e| format!("Failed to read team file {}: {}", file_path, e))?;

        let teams: Vec<RandomTeam> = serde_json::from_str(&file_content)
            .map_err(|e| format!("Failed to parse team file {}: {}", file_path, e))?;

        if teams.is_empty() {
            return Err(format!("No teams found in file: {}", file_path));
        }

        println!("Loaded {} teams for format: {}", teams.len(), format.name);
        self.teams_cache.insert(format_key, teams);
        Ok(())
    }

    /// Get a random team for the specified format
    pub fn get_random_team(&mut self, format: &BattleFormat) -> Result<RandomTeam, String> {
        // Ensure teams are loaded
        self.load_teams(format)?;

        let format_key = self.format_to_file_key(format);
        let teams = self
            .teams_cache
            .get(&format_key)
            .ok_or_else(|| format!("Teams not loaded for format: {}", format.name))?;

        if teams.is_empty() {
            return Err(format!("No teams available for format: {}", format.name));
        }

        // Select a random team
        let team = teams
            .choose(&mut self.rng)
            .ok_or_else(|| "Failed to select random team".to_string())?;

        Ok(team.clone())
    }

    /// Get multiple random teams for the specified format
    pub fn get_random_teams(
        &mut self,
        format: &BattleFormat,
        count: usize,
    ) -> Result<Vec<RandomTeam>, String> {
        let mut teams = Vec::with_capacity(count);
        for _ in 0..count {
            teams.push(self.get_random_team(format)?);
        }
        Ok(teams)
    }

    /// Get team count for a format
    pub fn get_team_count(&self, format: &BattleFormat) -> Option<usize> {
        let format_key = self.format_to_file_key(format);
        self.teams_cache.get(&format_key).map(|teams| teams.len())
    }

    /// Get a specific team by index for the specified format
    pub fn get_team_by_index(
        &mut self,
        format: &BattleFormat,
        index: usize,
    ) -> Result<RandomTeam, String> {
        // Ensure teams are loaded
        self.load_teams(format)?;

        let format_key = self.format_to_file_key(format);
        let teams = self
            .teams_cache
            .get(&format_key)
            .ok_or_else(|| format!("Teams not loaded for format: {}", format.name))?;

        if teams.is_empty() {
            return Err(format!("No teams available for format: {}", format.name));
        }

        if index >= teams.len() {
            return Err(format!(
                "Team index {} is out of range (0-{})",
                index,
                teams.len() - 1
            ));
        }

        Ok(teams[index].clone())
    }

    /// List all available format files
    pub fn list_available_formats() -> Result<Vec<String>, String> {
        let teams_dir = Path::new("data/random-teams");
        if !teams_dir.exists() {
            return Ok(Vec::new());
        }

        let mut formats = Vec::new();
        let entries = fs::read_dir(teams_dir)
            .map_err(|e| format!("Failed to read teams directory: {}", e))?;

        for entry in entries {
            let entry = entry.map_err(|e| format!("Failed to read directory entry: {}", e))?;
            let file_name = entry.file_name();
            let file_name_str = file_name.to_string_lossy();

            if file_name_str.ends_with("-teams.json") {
                let format_name = file_name_str.strip_suffix("-teams.json").unwrap();
                formats.push(format_name.to_string());
            }
        }

        Ok(formats)
    }

    /// Convert battle format to file key
    fn format_to_file_key(&self, format: &BattleFormat) -> String {
        match format.name.as_str() {
            "Gen 9 Random Battle" => "gen9randombattle".to_string(),
            "Gen 9 Random Doubles" => "gen9randomdoublesbattle".to_string(),
            "Gen 8 Random Battle" => "gen8randombattle".to_string(),
            "Gen 8 Random Doubles" => "gen8randomdoublesbattle".to_string(),
            "Gen 7 Random Battle" => "gen7randombattle".to_string(),
            _ => {
                // Fallback: convert format name to file key
                format.name.to_lowercase().replace(" ", "").replace("-", "")
            }
        }
    }
}

impl Default for RandomTeamLoader {
    fn default() -> Self {
        Self::new()
    }
}

/// Utility functions for working with random battle data
impl RandomPokemonSet {
    /// Get the Pokemon's nature as our internal Nature type
    pub fn get_nature(&self) -> Nature {
        match self.nature.as_ref().map(|s| s.as_str()) {
            Some("Hardy") => Nature::Hardy,
            Some("Lonely") => Nature::Lonely,
            Some("Brave") => Nature::Brave,
            Some("Adamant") => Nature::Adamant,
            Some("Naughty") => Nature::Naughty,
            Some("Bold") => Nature::Bold,
            Some("Docile") => Nature::Docile,
            Some("Relaxed") => Nature::Relaxed,
            Some("Impish") => Nature::Impish,
            Some("Lax") => Nature::Lax,
            Some("Timid") => Nature::Timid,
            Some("Hasty") => Nature::Hasty,
            Some("Serious") => Nature::Serious,
            Some("Jolly") => Nature::Jolly,
            Some("Naive") => Nature::Naive,
            Some("Modest") => Nature::Modest,
            Some("Mild") => Nature::Mild,
            Some("Quiet") => Nature::Quiet,
            Some("Bashful") => Nature::Bashful,
            Some("Rash") => Nature::Rash,
            Some("Calm") => Nature::Calm,
            Some("Gentle") => Nature::Gentle,
            Some("Sassy") => Nature::Sassy,
            Some("Careful") => Nature::Careful,
            Some("Quirky") => Nature::Quirky,
            _ => Nature::Hardy, // Default to Hardy if unknown
        }
    }

    /// Get the Pokemon's tera type as our internal PokemonType
    pub fn get_tera_type(&self) -> Option<PokemonType> {
        self.tera_type.as_ref().and_then(|t| match t.as_str() {
            "Normal" => Some(PokemonType::Normal),
            "Fire" => Some(PokemonType::Fire),
            "Water" => Some(PokemonType::Water),
            "Electric" => Some(PokemonType::Electric),
            "Grass" => Some(PokemonType::Grass),
            "Ice" => Some(PokemonType::Ice),
            "Fighting" => Some(PokemonType::Fighting),
            "Poison" => Some(PokemonType::Poison),
            "Ground" => Some(PokemonType::Ground),
            "Flying" => Some(PokemonType::Flying),
            "Psychic" => Some(PokemonType::Psychic),
            "Bug" => Some(PokemonType::Bug),
            "Rock" => Some(PokemonType::Rock),
            "Ghost" => Some(PokemonType::Ghost),
            "Dragon" => Some(PokemonType::Dragon),
            "Dark" => Some(PokemonType::Dark),
            "Steel" => Some(PokemonType::Steel),
            "Fairy" => Some(PokemonType::Fairy),
            _ => None,
        })
    }

    /// Get EVs with Smogon Random Battle optimization rules
    pub fn get_evs(&self, move_factory: &crate::data::ps_move_factory::PSMoveFactory) -> Stats {
        // Start with default Random Battle EVs
        let mut evs = match &self.evs {
            Some(evs) => evs.to_stats(85),
            None => Stats {
                hp: 85,
                attack: 85,
                defense: 85,
                special_attack: 85,
                special_defense: 85,
                speed: 85,
            },
        };

        // Apply Smogon Random Battle optimization rules
        let has_physical_moves = self.moves.iter().any(|move_name| {
            if let Some(move_data) = move_factory.create_move(move_name) {
                matches!(
                    move_data.category,
                    crate::core::state::MoveCategory::Physical
                )
            } else {
                false
            }
        });

        let has_speed_dependent_moves = self.moves.iter().any(|move_name| {
            let name_lower = move_name.to_lowercase();
            name_lower == "trick room" || name_lower == "gyro ball"
        });

        // No physical attacks: Attack EVs = 0
        if !has_physical_moves {
            evs.attack = 0;
        }

        // Has Trick Room or Gyro Ball: Speed EVs = 0
        if has_speed_dependent_moves {
            evs.speed = 0;
        }

        evs
    }

    /// Get IVs with Smogon Random Battle optimization rules
    pub fn get_ivs(&self, move_factory: &crate::data::ps_move_factory::PSMoveFactory) -> Stats {
        // Start with default Random Battle IVs (perfect)
        let mut ivs = match &self.ivs {
            Some(ivs) => ivs.to_stats(31),
            None => Stats {
                hp: 31,
                attack: 31,
                defense: 31,
                special_attack: 31,
                special_defense: 31,
                speed: 31,
            },
        };

        // Apply Smogon Random Battle optimization rules
        let has_physical_moves = self.moves.iter().any(|move_name| {
            if let Some(move_data) = move_factory.create_move(move_name) {
                matches!(
                    move_data.category,
                    crate::core::state::MoveCategory::Physical
                )
            } else {
                false
            }
        });

        let has_speed_dependent_moves = self.moves.iter().any(|move_name| {
            let name_lower = move_name.to_lowercase();
            name_lower == "trick room" || name_lower == "gyro ball"
        });

        // No physical attacks: Attack IVs = 0
        if !has_physical_moves {
            ivs.attack = 0;
        }

        // Has Trick Room or Gyro Ball: Speed IVs = 0
        if has_speed_dependent_moves {
            ivs.speed = 0;
        }

        ivs
    }

    /// Check if this Pokemon is shiny
    pub fn is_shiny(&self) -> bool {
        self.shiny.unwrap_or(false)
    }

    /// Check if this Pokemon has Gigantamax
    pub fn has_gigantamax(&self) -> bool {
        self.gigantamax.unwrap_or(false)
    }

    /// Convert to battle engine Pokemon
    pub fn to_battle_pokemon(
        &self,
        move_factory: &crate::data::ps_move_factory::PSMoveFactory,
        pokemon_factory: &crate::data::ps_pokemon_factory::PSPokemonFactory,
    ) -> Pokemon {
        let mut pokemon = Pokemon::new(self.species.clone());

        // Set basic attributes
        pokemon.level = self.level;
        // Set ability from random team data or default from PS data
        pokemon.ability = self
            .ability
            .clone()
            .unwrap_or_else(|| pokemon_factory.get_default_ability_with_fallback(&self.species));
        pokemon.item = self.item.clone();

        // Set gender
        pokemon.gender = match self.gender.as_ref().map(|s| s.as_str()) {
            Some("M") => Gender::Male,
            Some("F") => Gender::Female,
            _ => Gender::Unknown,
        };

        // Calculate stats from base stats, level, nature, IVs, EVs
        let base_stats = pokemon_factory.get_base_stats_with_fallback(&self.species);
        let nature = self.get_nature();
        let ivs = self.get_ivs(move_factory);
        let evs = self.get_evs(move_factory);

        // Calculate actual stats using Pokemon formula
        // HP = floor(((2 * base + iv + floor(ev / 4)) * level) / 100) + level + 10
        // Use i32 to prevent overflow during multiplication
        let hp = (((2 * base_stats.hp as i32 + ivs.hp as i32 + evs.hp as i32 / 4)
            * self.level as i32)
            / 100)
            + self.level as i32
            + 10;

        // Other stats = floor((floor(((2 * base + iv + floor(ev / 4)) * level) / 100) + 5) * nature_modifier)
        let attack = self.calculate_stat(
            base_stats.attack as i16,
            ivs.attack,
            evs.attack,
            nature.attack_modifier(),
        );
        let defense = self.calculate_stat(
            base_stats.defense as i16,
            ivs.defense,
            evs.defense,
            nature.defense_modifier(),
        );
        let special_attack = self.calculate_stat(
            base_stats.special_attack as i16,
            ivs.special_attack,
            evs.special_attack,
            nature.special_attack_modifier(),
        );
        let special_defense = self.calculate_stat(
            base_stats.special_defense as i16,
            ivs.special_defense,
            evs.special_defense,
            nature.special_defense_modifier(),
        );
        let speed = self.calculate_stat(
            base_stats.speed as i16,
            ivs.speed,
            evs.speed,
            nature.speed_modifier(),
        );

        pokemon.hp = hp as i16;
        pokemon.max_hp = hp as i16;
        pokemon.stats = Stats {
            hp: hp as i16,
            attack,
            defense,
            special_attack,
            special_defense,
            speed,
        };

        // Set types from PS data
        pokemon.types = pokemon_factory.get_types_with_fallback(&self.species);

        // Add moves to the Pokemon
        for (index, move_name) in self.moves.iter().enumerate() {
            if index >= 4 {
                break;
            } // Pokemon can only have 4 moves

            // Create move using PS data
            let move_data = match move_factory.create_move(move_name) {
                Some(mv) => mv,
                None => {
                    // Fallback if move not found in PS data
                    eprintln!(
                        "Warning: Move '{}' not found in PS data, using placeholder",
                        move_name
                    );
                    crate::core::state::Move {
                        name: move_name.clone(),
                        base_power: 80,
                        move_type: "Normal".to_string(),
                        category: crate::core::state::MoveCategory::Physical,
                        accuracy: 100,
                        pp: 20,
                        max_pp: 20,
                        priority: 0,
                        target: crate::data::ps_types::PSMoveTarget::Normal,
                    }
                }
            };

            let move_index = match index {
                0 => crate::core::move_choice::MoveIndex::M0,
                1 => crate::core::move_choice::MoveIndex::M1,
                2 => crate::core::move_choice::MoveIndex::M2,
                3 => crate::core::move_choice::MoveIndex::M3,
                _ => continue,
            };

            pokemon.moves.insert(move_index, move_data);
        }

        // Set tera type if available (Gen 9+ only)
        // Note: Could add generation check here if needed
        pokemon.tera_type = self.get_tera_type();

        pokemon
    }

    /// Calculate a stat using the Pokemon formula
    fn calculate_stat(&self, base: i16, iv: i16, ev: i16, nature_modifier: f64) -> i16 {
        // Use i32 to prevent overflow during multiplication
        let stat = (((2 * base as i32 + iv as i32 + ev as i32 / 4) * self.level as i32) / 100) + 5;
        let final_stat = (stat as f64 * nature_modifier) as i16;
        final_stat
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::battle_format::BattleFormat;

    #[test]
    fn test_random_stats_conversion() {
        let random_stats = RandomStats {
            hp: Some(100),
            atk: Some(0),
            def: Some(50),
            spa: None,
            spd: Some(75),
            spe: None,
        };

        let stats = random_stats.to_stats(85);
        assert_eq!(stats.hp, 100);
        assert_eq!(stats.attack, 0);
        assert_eq!(stats.defense, 50);
        assert_eq!(stats.special_attack, 85); // Default value
        assert_eq!(stats.special_defense, 75);
        assert_eq!(stats.speed, 85); // Default value
    }

    #[test]
    fn test_format_to_file_key() {
        let loader = RandomTeamLoader::new();

        let gen9_random = BattleFormat::gen9_random_battle();
        assert_eq!(loader.format_to_file_key(&gen9_random), "gen9randombattle");

        let gen9_doubles = BattleFormat::gen9_random_doubles();
        assert_eq!(
            loader.format_to_file_key(&gen9_doubles),
            "gen9randomdoublesbattle"
        );
    }

    #[test]
    fn test_pokemon_set_utilities() {
        let pokemon = RandomPokemonSet {
            name: "Pikachu".to_string(),
            species: "Pikachu".to_string(),
            level: 50,
            gender: Some("M".to_string()),
            shiny: Some(true),
            ability: Some("Static".to_string()),
            item: Some("Light Ball".to_string()),
            moves: vec!["Thunderbolt".to_string(), "Quick Attack".to_string()],
            nature: Some("Timid".to_string()),
            evs: None,
            ivs: None,
            tera_type: Some("Electric".to_string()),
            role: Some("Fast Attacker".to_string()),
            gigantamax: Some(false),
        };

        assert_eq!(pokemon.get_nature(), Nature::Timid);
        assert_eq!(pokemon.get_tera_type(), Some(PokemonType::Electric));
        assert!(pokemon.is_shiny());
        assert!(!pokemon.has_gigantamax());

        // Create a mock move factory for testing
        let move_factory = crate::data::ps_move_factory::PSMoveFactory::new()
            .expect("Failed to create move factory");
        let evs = pokemon.get_evs(&move_factory);
        assert_eq!(evs.hp, 85);
        assert_eq!(evs.speed, 85);
    }
}
