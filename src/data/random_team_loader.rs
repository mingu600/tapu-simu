//! # Random Team Loader
//!
//! This module provides functionality to load and sample random battle teams
//! from JSON files generated by our ps-data-extractor tool.

use crate::core::battle_format::BattleFormat;
use crate::core::move_choice::PokemonType;
use crate::core::battle_state::{Gender, Pokemon};
use crate::data::types::{Nature, Stats};
use rand::rngs::StdRng;
use rand::seq::SliceRandom;
use rand::SeedableRng;
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;

/// Represents a Pokemon set from random battle data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RandomPokemonSet {
    pub name: String,
    pub species: String,
    pub level: u8,
    pub gender: Option<String>,
    pub shiny: Option<bool>,
    pub ability: Option<String>,
    pub item: Option<String>,
    pub moves: Vec<String>,
    pub nature: Option<String>,
    pub evs: Option<RandomStats>,
    pub ivs: Option<RandomStats>,
    #[serde(rename = "teraType")]
    pub tera_type: Option<String>,
    pub role: Option<String>,
    pub gigantamax: Option<bool>,
}

/// Stats structure for EVs/IVs from random battle data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RandomStats {
    pub hp: Option<u8>,
    pub atk: Option<u8>,
    pub def: Option<u8>,
    pub spa: Option<u8>,
    pub spd: Option<u8>,
    pub spe: Option<u8>,
}

impl RandomStats {
    /// Convert to our internal Stats type with defaults
    pub fn to_stats(&self, default_value: u8) -> Stats {
        Stats {
            hp: self.hp.unwrap_or(default_value) as i16,
            attack: self.atk.unwrap_or(default_value) as i16,
            defense: self.def.unwrap_or(default_value) as i16,
            special_attack: self.spa.unwrap_or(default_value) as i16,
            special_defense: self.spd.unwrap_or(default_value) as i16,
            speed: self.spe.unwrap_or(default_value) as i16,
        }
    }
}

/// A complete random battle team (6 Pokemon)
pub type RandomTeam = Vec<RandomPokemonSet>;

/// Random team loader that manages loading and sampling teams
#[derive(Debug)]
pub struct RandomTeamLoader {
    teams_cache: std::collections::HashMap<String, Vec<RandomTeam>>,
    rng: StdRng,
}

impl RandomTeamLoader {
    /// Create a new random team loader
    pub fn new() -> Self {
        Self {
            teams_cache: std::collections::HashMap::new(),
            rng: StdRng::from_entropy(),
        }
    }

    /// Create a new random team loader with a specific seed for deterministic results
    pub fn with_seed(seed: u64) -> Self {
        Self {
            teams_cache: std::collections::HashMap::new(),
            rng: StdRng::seed_from_u64(seed),
        }
    }

    /// Load teams for a specific format
    pub fn load_teams(&mut self, format: &BattleFormat) -> Result<(), String> {
        let format_key = self.format_to_file_key(format);

        // Check if already loaded
        if self.teams_cache.contains_key(&format_key) {
            return Ok(());
        }

        let file_path = format!("data/random-teams/{}-teams.json", format_key);

        if !Path::new(&file_path).exists() {
            return Err(format!(
                "Team file not found: {}. Run team generation first.",
                file_path
            ));
        }

        let file_content = fs::read_to_string(&file_path)
            .map_err(|e| format!("Failed to read team file {}: {}", file_path, e))?;

        let teams: Vec<RandomTeam> = serde_json::from_str(&file_content)
            .map_err(|e| format!("Failed to parse team file {}: {}", file_path, e))?;

        if teams.is_empty() {
            return Err(format!("No teams found in file: {}", file_path));
        }

        println!("Loaded {} teams for format: {}", teams.len(), format.name);
        self.teams_cache.insert(format_key, teams);
        Ok(())
    }

    /// Get a random team for the specified format
    pub fn get_random_team(&mut self, format: &BattleFormat) -> Result<RandomTeam, String> {
        // Ensure teams are loaded
        self.load_teams(format)?;

        let format_key = self.format_to_file_key(format);
        let teams = self
            .teams_cache
            .get(&format_key)
            .ok_or_else(|| format!("Teams not loaded for format: {}", format.name))?;

        if teams.is_empty() {
            return Err(format!("No teams available for format: {}", format.name));
        }

        // Select a random team
        let team = teams
            .choose(&mut self.rng)
            .ok_or_else(|| "Failed to select random team".to_string())?;

        Ok(team.clone())
    }

    /// Get multiple random teams for the specified format
    pub fn get_random_teams(
        &mut self,
        format: &BattleFormat,
        count: usize,
    ) -> Result<Vec<RandomTeam>, String> {
        let mut teams = Vec::with_capacity(count);
        for _ in 0..count {
            teams.push(self.get_random_team(format)?);
        }
        Ok(teams)
    }

    /// Get team count for a format
    pub fn get_team_count(&self, format: &BattleFormat) -> Option<usize> {
        let format_key = self.format_to_file_key(format);
        self.teams_cache.get(&format_key).map(|teams| teams.len())
    }

    /// Get a specific team by index for the specified format
    pub fn get_team_by_index(
        &mut self,
        format: &BattleFormat,
        index: usize,
    ) -> Result<RandomTeam, String> {
        // Ensure teams are loaded
        self.load_teams(format)?;

        let format_key = self.format_to_file_key(format);
        let teams = self
            .teams_cache
            .get(&format_key)
            .ok_or_else(|| format!("Teams not loaded for format: {}", format.name))?;

        if teams.is_empty() {
            return Err(format!("No teams available for format: {}", format.name));
        }

        if index >= teams.len() {
            return Err(format!(
                "Team index {} is out of range (0-{})",
                index,
                teams.len() - 1
            ));
        }

        Ok(teams[index].clone())
    }

    /// List all available format files
    pub fn list_available_formats() -> Result<Vec<String>, String> {
        let teams_dir = Path::new("data/random-teams");
        if !teams_dir.exists() {
            return Ok(Vec::new());
        }

        let mut formats = Vec::new();
        let entries = fs::read_dir(teams_dir)
            .map_err(|e| format!("Failed to read teams directory: {}", e))?;

        for entry in entries {
            let entry = entry.map_err(|e| format!("Failed to read directory entry: {}", e))?;
            let file_name = entry.file_name();
            let file_name_str = file_name.to_string_lossy();

            if file_name_str.ends_with("-teams.json") {
                let format_name = file_name_str.strip_suffix("-teams.json").unwrap();
                formats.push(format_name.to_string());
            }
        }

        Ok(formats)
    }

    /// Convert battle format to file key
    fn format_to_file_key(&self, format: &BattleFormat) -> String {
        match format.name.as_str() {
            "Gen 9 Random Battle" => "gen9randombattle".to_string(),
            "Gen 9 Random Doubles" => "gen9randomdoublesbattle".to_string(),
            "Gen 8 Random Battle" => "gen8randombattle".to_string(),
            "Gen 8 Random Doubles" => "gen8randomdoublesbattle".to_string(),
            "Gen 7 Random Battle" => "gen7randombattle".to_string(),
            _ => {
                // Fallback: convert format name to file key
                format.name.to_lowercase().replace(" ", "").replace("-", "")
            }
        }
    }
}

impl Default for RandomTeamLoader {
    fn default() -> Self {
        Self::new()
    }
}

/// Utility functions for working with random battle data
impl RandomPokemonSet {
    /// Get the Pokemon's nature as our internal Nature type
    pub fn get_nature(&self) -> Nature {
        match self.nature.as_ref().map(|s| s.as_str()) {
            Some("Hardy") => Nature::Hardy,
            Some("Lonely") => Nature::Lonely,
            Some("Brave") => Nature::Brave,
            Some("Adamant") => Nature::Adamant,
            Some("Naughty") => Nature::Naughty,
            Some("Bold") => Nature::Bold,
            Some("Docile") => Nature::Docile,
            Some("Relaxed") => Nature::Relaxed,
            Some("Impish") => Nature::Impish,
            Some("Lax") => Nature::Lax,
            Some("Timid") => Nature::Timid,
            Some("Hasty") => Nature::Hasty,
            Some("Serious") => Nature::Serious,
            Some("Jolly") => Nature::Jolly,
            Some("Naive") => Nature::Naive,
            Some("Modest") => Nature::Modest,
            Some("Mild") => Nature::Mild,
            Some("Quiet") => Nature::Quiet,
            Some("Bashful") => Nature::Bashful,
            Some("Rash") => Nature::Rash,
            Some("Calm") => Nature::Calm,
            Some("Gentle") => Nature::Gentle,
            Some("Sassy") => Nature::Sassy,
            Some("Careful") => Nature::Careful,
            Some("Quirky") => Nature::Quirky,
            _ => Nature::Hardy, // Default to Hardy if unknown
        }
    }

    /// Get the Pokemon's tera type as our internal PokemonType
    pub fn get_tera_type(&self) -> Option<PokemonType> {
        self.tera_type.as_ref().and_then(|t| match t.as_str() {
            "Normal" => Some(PokemonType::Normal),
            "Fire" => Some(PokemonType::Fire),
            "Water" => Some(PokemonType::Water),
            "Electric" => Some(PokemonType::Electric),
            "Grass" => Some(PokemonType::Grass),
            "Ice" => Some(PokemonType::Ice),
            "Fighting" => Some(PokemonType::Fighting),
            "Poison" => Some(PokemonType::Poison),
            "Ground" => Some(PokemonType::Ground),
            "Flying" => Some(PokemonType::Flying),
            "Psychic" => Some(PokemonType::Psychic),
            "Bug" => Some(PokemonType::Bug),
            "Rock" => Some(PokemonType::Rock),
            "Ghost" => Some(PokemonType::Ghost),
            "Dragon" => Some(PokemonType::Dragon),
            "Dark" => Some(PokemonType::Dark),
            "Steel" => Some(PokemonType::Steel),
            "Fairy" => Some(PokemonType::Fairy),
            _ => None,
        })
    }

    /// Get EVs with Smogon Random Battle optimization rules
    pub fn get_evs(&self, repository: &crate::data::GameDataRepository) -> Stats {
        // Start with default Random Battle EVs
        let mut evs = match &self.evs {
            Some(evs) => evs.to_stats(85),
            None => Stats {
                hp: 85,
                attack: 85,
                defense: 85,
                special_attack: 85,
                special_defense: 85,
                speed: 85,
            },
        };

        // Apply Smogon Random Battle optimization rules
        let has_physical_moves = self.moves.iter().any(|move_name| {
            use crate::types::identifiers::MoveId;
            let move_id = MoveId::from(move_name.clone());
            if let Ok(move_data) = repository.moves.find_by_id(&move_id) {
                move_data.category == "Physical"
            } else {
                false
            }
        });

        let has_speed_dependent_moves = self.moves.iter().any(|move_name| {
            let name_lower = move_name.to_lowercase();
            name_lower == "trick room" || name_lower == "gyro ball"
        });

        // No physical attacks: Attack EVs = 0
        if !has_physical_moves {
            evs.attack = 0;
        }

        // Has Trick Room or Gyro Ball: Speed EVs = 0
        if has_speed_dependent_moves {
            evs.speed = 0;
        }

        evs
    }

    /// Get IVs with Smogon Random Battle optimization rules
    pub fn get_ivs(&self, repository: &crate::data::GameDataRepository) -> Stats {
        // Start with default Random Battle IVs (perfect)
        let mut ivs = match &self.ivs {
            Some(ivs) => ivs.to_stats(31),
            None => Stats {
                hp: 31,
                attack: 31,
                defense: 31,
                special_attack: 31,
                special_defense: 31,
                speed: 31,
            },
        };

        // Apply Smogon Random Battle optimization rules
        let has_physical_moves = self.moves.iter().any(|move_name| {
            use crate::types::identifiers::MoveId;
            let move_id = MoveId::from(move_name.clone());
            if let Ok(move_data) = repository.moves.find_by_id(&move_id) {
                move_data.category == "Physical"
            } else {
                false
            }
        });

        let has_speed_dependent_moves = self.moves.iter().any(|move_name| {
            let name_lower = move_name.to_lowercase();
            name_lower == "trick room" || name_lower == "gyro ball"
        });

        // No physical attacks: Attack IVs = 0
        if !has_physical_moves {
            ivs.attack = 0;
        }

        // Has Trick Room or Gyro Ball: Speed IVs = 0
        if has_speed_dependent_moves {
            ivs.speed = 0;
        }

        ivs
    }

    /// Check if this Pokemon is shiny
    pub fn is_shiny(&self) -> bool {
        self.shiny.unwrap_or(false)
    }

    /// Check if this Pokemon has Gigantamax
    pub fn has_gigantamax(&self) -> bool {
        self.gigantamax.unwrap_or(false)
    }

    /// Convert to battle engine Pokemon
    pub fn to_battle_pokemon(
        &self,
        repository: &crate::data::GameDataRepository,
    ) -> Pokemon {
        let mut pokemon = Pokemon::new(self.species.clone());

        // Set basic attributes
        pokemon.level = self.level;
        // Set ability from random team data or default from PS data
        use crate::types::identifiers::{AbilityId, SpeciesId};
        pokemon.ability = if let Some(ability_name) = &self.ability {
            ability_name.clone()
        } else {
            // Get default ability from repository
            let species_id = SpeciesId::from(self.species.clone());
            if let Ok(pokemon_data) = repository.pokemon.find_by_id(&species_id) {
                // Get first ability if available (slot "0")
                pokemon_data.abilities.get("0")
                    .cloned()
                    .unwrap_or_else(|| AbilityId::new(""))
                    .to_string()
            } else {
                String::new()
            }
        };
        pokemon.item = self.item.clone();

        // Set gender
        pokemon.gender = match self.gender.as_ref().map(|s| s.as_str()) {
            Some("M") => Gender::Male,
            Some("F") => Gender::Female,
            _ => Gender::Unknown,
        };

        // Calculate stats from base stats, level, nature, IVs, EVs
        let species_id = SpeciesId::from(self.species.clone());
        let base_stats = if let Ok(pokemon_data) = repository.pokemon.find_by_id(&species_id) {
            pokemon_data.base_stats.to_engine_stats()
        } else {
            eprintln!("Warning: Base stats for '{}' not found in PS data, using fallback", self.species);
            // Use reasonable fallback stats
            crate::data::types::EngineBaseStats {
                hp: 70,
                attack: 70,
                defense: 70,
                special_attack: 70,
                special_defense: 70,
                speed: 70,
            }
        };
        let nature = self.get_nature();
        let ivs = self.get_ivs(repository);
        let evs = self.get_evs(repository);

        // Calculate actual stats using Pokemon formula
        // HP = floor(((2 * base + iv + floor(ev / 4)) * level) / 100) + level + 10
        // Use i32 to prevent overflow during multiplication
        let hp = (((2 * base_stats.hp as i32 + ivs.hp as i32 + evs.hp as i32 / 4)
            * self.level as i32)
            / 100)
            + self.level as i32
            + 10;

        // Other stats = floor((floor(((2 * base + iv + floor(ev / 4)) * level) / 100) + 5) * nature_modifier)
        let attack = self.calculate_stat(
            base_stats.attack as i16,
            ivs.attack,
            evs.attack,
            nature.attack_modifier(),
        );
        let defense = self.calculate_stat(
            base_stats.defense as i16,
            ivs.defense,
            evs.defense,
            nature.defense_modifier(),
        );
        let special_attack = self.calculate_stat(
            base_stats.special_attack as i16,
            ivs.special_attack,
            evs.special_attack,
            nature.special_attack_modifier(),
        );
        let special_defense = self.calculate_stat(
            base_stats.special_defense as i16,
            ivs.special_defense,
            evs.special_defense,
            nature.special_defense_modifier(),
        );
        let speed = self.calculate_stat(
            base_stats.speed as i16,
            ivs.speed,
            evs.speed,
            nature.speed_modifier(),
        );

        pokemon.hp = hp as i16;
        pokemon.max_hp = hp as i16;
        pokemon.stats = Stats {
            hp: hp as i16,
            attack,
            defense,
            special_attack,
            special_defense,
            speed,
        };

        // Set types from PS data
        pokemon.types = if let Ok(pokemon_data) = repository.pokemon.find_by_id(&species_id) {
            pokemon_data.types.iter().map(|type_id| type_id.as_str().to_string()).collect()
        } else {
            eprintln!("Warning: Types for '{}' not found in PS data, using Normal type", self.species);
            vec!["Normal".to_string()]
        };

        // Add moves to the Pokemon
        for (index, move_name) in self.moves.iter().enumerate() {
            if index >= 4 {
                break;
            } // Pokemon can only have 4 moves

            // Create move using PS data
            use crate::types::identifiers::MoveId;
            let move_id = MoveId::from(move_name.clone());
            let move_data = match repository.moves.create_move(&move_id) {
                Ok(mv) => mv,
                Err(_) => {
                    // Fallback if move not found in PS data
                    eprintln!(
                        "Warning: Move '{}' not found in PS data, using placeholder",
                        move_name
                    );
                    crate::core::battle_state::Move {
                        name: move_name.clone(),
                        base_power: 80,
                        move_type: "Normal".to_string(),
                        category: crate::core::battle_state::MoveCategory::Physical,
                        accuracy: 100,
                        pp: 20,
                        max_pp: 20,
                        priority: 0,
                        target: crate::data::showdown_types::MoveTarget::Normal,
                    }
                }
            };

            let move_index = match index {
                0 => crate::core::move_choice::MoveIndex::M0,
                1 => crate::core::move_choice::MoveIndex::M1,
                2 => crate::core::move_choice::MoveIndex::M2,
                3 => crate::core::move_choice::MoveIndex::M3,
                _ => continue,
            };

            pokemon.moves.insert(move_index, move_data);
        }

        // Set tera type if available (Gen 9+ only)
        // Note: Could add generation check here if needed
        pokemon.tera_type = self.get_tera_type();

        // Set weight from repository data
        pokemon.weight_kg = repository.pokemon.get_pokemon_weight(&self.species).unwrap_or(50.0);

        pokemon
    }

    /// Calculate a stat using the Pokemon formula
    fn calculate_stat(&self, base: i16, iv: i16, ev: i16, nature_modifier: f64) -> i16 {
        // Use i32 to prevent overflow during multiplication
        let stat = (((2 * base as i32 + iv as i32 + ev as i32 / 4) * self.level as i32) / 100) + 5;
        let final_stat = (stat as f64 * nature_modifier) as i16;
        final_stat
    }
}

