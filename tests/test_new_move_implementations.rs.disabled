use tapu_simu::core::state::State;
use tapu_simu::core::battle_format::{BattleFormat, BattlePosition, SideReference};
use tapu_simu::core::instruction::{Terrain, PokemonStatus, VolatileStatus};
use tapu_simu::engine::combat::move_effects::{
    apply_expanding_force, apply_rising_voltage, apply_misty_explosion, apply_psy_blade,
    apply_steel_roller, apply_ice_spinner, apply_mind_blown, apply_ivy_cudgel, apply_tera_blast
};
use tapu_simu::data::types::EngineMoveData;
use tapu_simu::generation::{GenerationMechanics, Generation};
use tapu_simu::testing::framework::TestFramework;

#[test]
fn test_expanding_force_psychic_terrain_boost() {
    let framework = TestFramework::new().unwrap();
    let mut state = State::new(BattleFormat::gen9_ou());
    
    // Set up Pokemon
    let attacker = framework.create_pokemon_from_ps_data("alakazam", None, None).unwrap();
    let defender = framework.create_pokemon_from_ps_data("blissey", None, None).unwrap();
    
    state.side_one.pokemon = vec![attacker];
    state.side_one.set_active_pokemon_at_slot(0, Some(0));
    state.side_two.pokemon = vec![defender];
    state.side_two.set_active_pokemon_at_slot(0, Some(0));
    
    // Set Psychic Terrain
    state.terrain = Terrain::PsychicTerrain;
    state.terrain_turns_remaining = Some(5);
    
    let move_data = EngineMoveData {
        id: 1,
        name: "Expanding Force".to_string(),
        base_power: Some(80),
        accuracy: Some(100),
        pp: 10,
        move_type: "Psychic".to_string(),
        category: tapu_simu::core::state::MoveCategory::Special,
        priority: 0,
        target: tapu_simu::data::ps_types::PSMoveTarget::Normal,
        effect_chance: None,
        effect_description: "Boosted power in Psychic Terrain".to_string(),
        flags: vec![],
    };
    
    let user_position = BattlePosition { side: SideReference::SideOne, slot: 0 };
    let target_positions = vec![BattlePosition { side: SideReference::SideTwo, slot: 0 }];
    let generation = GenerationMechanics::new(Generation::Gen9);
    
    // Test in Psychic Terrain (should get power boost)
    let result = apply_expanding_force(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result.is_empty(), "Expanding Force should produce instructions in Psychic Terrain");
    
    // Test without terrain
    state.terrain = Terrain::None;
    let result_no_terrain = apply_expanding_force(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result_no_terrain.is_empty(), "Expanding Force should still work without terrain");
}

#[test]
fn test_rising_voltage_electric_terrain_boost() {
    let framework = TestFramework::new().unwrap();
    let mut state = State::new(BattleFormat::gen9_ou());
    
    // Set up Pokemon
    let attacker = framework.create_pokemon_from_ps_data("magnezone", None, None).unwrap();
    let defender = framework.create_pokemon_from_ps_data("starmie", None, None).unwrap();
    
    state.side_one.pokemon = vec![attacker];
    state.side_one.set_active_pokemon_at_slot(0, Some(0));
    state.side_two.pokemon = vec![defender];
    state.side_two.set_active_pokemon_at_slot(0, Some(0));
    
    // Set Electric Terrain
    state.terrain = Terrain::ElectricTerrain;
    state.terrain_turns_remaining = Some(5);
    
    let move_data = EngineMoveData {
        id: 2,
        name: "Rising Voltage".to_string(),
        base_power: Some(70),
        accuracy: Some(100),
        pp: 20,
        move_type: "Electric".to_string(),
        category: tapu_simu::core::state::MoveCategory::Special,
        priority: 0,
        target: tapu_simu::data::ps_types::PSMoveTarget::Normal,
        effect_chance: None,
        effect_description: "Boosted power in Electric Terrain".to_string(),
        flags: vec![],
    };
    
    let user_position = BattlePosition { side: SideReference::SideOne, slot: 0 };
    let target_positions = vec![BattlePosition { side: SideReference::SideTwo, slot: 0 }];
    let generation = GenerationMechanics::new(Generation::Gen9);
    
    // Test in Electric Terrain (should get power boost)
    let result = apply_rising_voltage(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result.is_empty(), "Rising Voltage should produce instructions in Electric Terrain");
}

#[test]
fn test_steel_roller_terrain_requirements() {
    let framework = TestFramework::new().unwrap();
    let mut state = State::new(BattleFormat::gen9_ou());
    
    // Set up Pokemon
    let attacker = framework.create_pokemon_from_ps_data("metagross", None, None).unwrap();
    let defender = framework.create_pokemon_from_ps_data("garchomp", None, None).unwrap();
    
    state.side_one.pokemon = vec![attacker];
    state.side_one.set_active_pokemon_at_slot(0, Some(0));
    state.side_two.pokemon = vec![defender];
    state.side_two.set_active_pokemon_at_slot(0, Some(0));
    
    let move_data = EngineMoveData {
        id: 3,
        name: "Steel Roller".to_string(),
        base_power: Some(130),
        accuracy: Some(100),
        pp: 5,
        move_type: "Steel".to_string(),
        category: tapu_simu::core::state::MoveCategory::Physical,
        priority: 0,
        target: tapu_simu::data::ps_types::PSMoveTarget::Normal,
        effect_chance: None,
        effect_description: "Fails without terrain".to_string(),
        flags: vec![],
    };
    
    let user_position = BattlePosition { side: SideReference::SideOne, slot: 0 };
    let target_positions = vec![BattlePosition { side: SideReference::SideTwo, slot: 0 }];
    let generation = GenerationMechanics::new(Generation::Gen9);
    
    // Test without terrain (should fail)
    state.terrain = Terrain::None;
    let result_no_terrain = apply_steel_roller(&state, &move_data, user_position, &target_positions, &generation);
    assert!(result_no_terrain.is_empty() || result_no_terrain[0].instruction_list.is_empty(), 
        "Steel Roller should fail when no terrain is active");
    
    // Test with terrain (should succeed and remove terrain)
    state.terrain = Terrain::ElectricTerrain;
    state.terrain_turns_remaining = Some(3);
    let result_with_terrain = apply_steel_roller(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result_with_terrain.is_empty(), "Steel Roller should work when terrain is active");
}

#[test]
fn test_mind_blown_self_damage() {
    let framework = TestFramework::new().unwrap();
    let mut state = State::new(BattleFormat::gen9_ou());
    
    // Set up Pokemon with known HP
    let mut attacker = framework.create_pokemon_from_ps_data("blacephalon", None, None).unwrap();
    attacker.hp = 200;
    attacker.max_hp = 200;
    
    let defender = framework.create_pokemon_from_ps_data("toxapex", None, None).unwrap();
    
    state.side_one.pokemon = vec![attacker];
    state.side_one.set_active_pokemon_at_slot(0, Some(0));
    state.side_two.pokemon = vec![defender];
    state.side_two.set_active_pokemon_at_slot(0, Some(0));
    
    let move_data = EngineMoveData {
        id: 4,
        name: "Mind Blown".to_string(),
        base_power: Some(150),
        accuracy: Some(100),
        pp: 5,
        move_type: "Fire".to_string(),
        category: tapu_simu::core::state::MoveCategory::Special,
        priority: 0,
        target: tapu_simu::data::ps_types::PSMoveTarget::Normal,
        effect_chance: None,
        effect_description: "Damages user for 1/2 max HP".to_string(),
        flags: vec![],
    };
    
    let user_position = BattlePosition { side: SideReference::SideOne, slot: 0 };
    let target_positions = vec![BattlePosition { side: SideReference::SideTwo, slot: 0 }];
    let generation = GenerationMechanics::new(Generation::Gen9);
    
    let result = apply_mind_blown(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result.is_empty(), "Mind Blown should produce instructions for self-damage");
    
    // Should have self-damage instruction
    let has_self_damage = result.iter().any(|si| {
        si.instruction_list.iter().any(|instr| {
            matches!(instr, tapu_simu::core::instruction::Instruction::PositionDamage(dmg_instr)
                if dmg_instr.target_position == user_position)
        })
    });
    assert!(has_self_damage, "Mind Blown should include self-damage instruction");
}

#[test]
fn test_ivy_cudgel_item_type_change() {
    let framework = TestFramework::new().unwrap();
    let mut state = State::new(BattleFormat::gen9_ou());
    
    // Set up Ogerpon with different masks
    let mut attacker = framework.create_pokemon_from_ps_data("ogerpon", None, None).unwrap();
    attacker.item = Some("wellspringmask".to_string()); // Should make move Water-type
    
    let defender = framework.create_pokemon_from_ps_data("charizard", None, None).unwrap();
    
    state.side_one.pokemon = vec![attacker];
    state.side_one.set_active_pokemon_at_slot(0, Some(0));
    state.side_two.pokemon = vec![defender];
    state.side_two.set_active_pokemon_at_slot(0, Some(0));
    
    let move_data = EngineMoveData {
        id: 5,
        name: "Ivy Cudgel".to_string(),
        base_power: Some(100),
        accuracy: Some(100),
        pp: 10,
        move_type: "Grass".to_string(), // Base type is Grass
        category: tapu_simu::core::state::MoveCategory::Physical,
        priority: 0,
        target: tapu_simu::data::ps_types::PSMoveTarget::Normal,
        effect_chance: None,
        effect_description: "Type changes with mask items".to_string(),
        flags: vec![],
    };
    
    let user_position = BattlePosition { side: SideReference::SideOne, slot: 0 };
    let target_positions = vec![BattlePosition { side: SideReference::SideTwo, slot: 0 }];
    let generation = GenerationMechanics::new(Generation::Gen9);
    
    let result = apply_ivy_cudgel(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result.is_empty(), "Ivy Cudgel should produce instructions");
    
    // Test with no mask (should remain Grass type)
    state.side_one.pokemon[0].item = None;
    let result_no_mask = apply_ivy_cudgel(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result_no_mask.is_empty(), "Ivy Cudgel should work without mask item");
}

#[test]
fn test_ice_spinner_terrain_removal() {
    let framework = TestFramework::new().unwrap();
    let mut state = State::new(BattleFormat::gen9_ou());
    
    // Set up Pokemon
    let attacker = framework.create_pokemon_from_ps_data("cetitan", None, None).unwrap();
    let defender = framework.create_pokemon_from_ps_data("landorus", None, None).unwrap();
    
    state.side_one.pokemon = vec![attacker];
    state.side_one.set_active_pokemon_at_slot(0, Some(0));
    state.side_two.pokemon = vec![defender];
    state.side_two.set_active_pokemon_at_slot(0, Some(0));
    
    // Set up terrain to be removed
    state.terrain = Terrain::GrassyTerrain;
    state.terrain_turns_remaining = Some(4);
    
    let move_data = EngineMoveData {
        id: 6,
        name: "Ice Spinner".to_string(),
        base_power: Some(80),
        accuracy: Some(100),
        pp: 15,
        move_type: "Ice".to_string(),
        category: tapu_simu::core::state::MoveCategory::Physical,
        priority: 0,
        target: tapu_simu::data::ps_types::PSMoveTarget::Normal,
        effect_chance: None,
        effect_description: "Removes terrain after hitting".to_string(),
        flags: vec![],
    };
    
    let user_position = BattlePosition { side: SideReference::SideOne, slot: 0 };
    let target_positions = vec![BattlePosition { side: SideReference::SideTwo, slot: 0 }];
    let generation = GenerationMechanics::new(Generation::Gen9);
    
    let result = apply_ice_spinner(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result.is_empty(), "Ice Spinner should produce instructions");
    
    // Should have terrain removal instruction when terrain is active
    let has_terrain_change = result.iter().any(|si| {
        si.instruction_list.iter().any(|instr| {
            matches!(instr, tapu_simu::core::instruction::Instruction::ChangeTerrain(_))
        })
    });
    assert!(has_terrain_change, "Ice Spinner should include terrain removal instruction when terrain is active");
    
    // Test without terrain
    state.terrain = Terrain::None;
    let result_no_terrain = apply_ice_spinner(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result_no_terrain.is_empty(), "Ice Spinner should still work without terrain");
}