use tapu_simu::core::state::State;
use tapu_simu::core::battle_format::{BattleFormat, BattlePosition, SideReference};
use tapu_simu::core::instruction::{Weather, PokemonStatus, SideCondition};
use tapu_simu::engine::combat::move_effects::{
    apply_blizzard, apply_hurricane, apply_thunder, apply_aura_wheel, apply_raging_bull,
    apply_photon_geyser, apply_sky_drop, apply_mortal_spin
};
use tapu_simu::data::types::EngineMoveData;
use tapu_simu::generation::{GenerationMechanics, Generation};
use tapu_simu::testing::framework::TestFramework;

#[test]
fn test_blizzard_weather_accuracy() {
    let framework = TestFramework::new().unwrap();
    let mut state = State::new(BattleFormat::gen9_ou());
    
    // Set up Pokemon
    let attacker = framework.create_pokemon_from_ps_data("articuno", None, None).unwrap();
    let defender = framework.create_pokemon_from_ps_data("charizard", None, None).unwrap();
    
    state.side_one.pokemon = vec![attacker];
    state.side_one.set_active_pokemon_at_slot(0, Some(0));
    state.side_two.pokemon = vec![defender];
    state.side_two.set_active_pokemon_at_slot(0, Some(0));
    
    let move_data = EngineMoveData {
        id: 1,
        name: "Blizzard".to_string(),
        base_power: Some(110),
        accuracy: Some(70), // Base 70% accuracy
        pp: 5,
        move_type: "Ice".to_string(),
        category: tapu_simu::core::state::MoveCategory::Special,
        priority: 0,
        target: tapu_simu::data::ps_types::PSMoveTarget::Normal,
        effect_chance: None,
        effect_description: "100% accuracy in hail/snow".to_string(),
        flags: vec![],
    };
    
    let user_position = BattlePosition { side: SideReference::SideOne, slot: 0 };
    let target_positions = vec![BattlePosition { side: SideReference::SideTwo, slot: 0 }];
    let generation = GenerationMechanics::new(Generation::Gen9);
    
    // Test in normal weather (should use base accuracy)
    state.weather = Weather::None;
    let result_normal = apply_blizzard(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result_normal.is_empty(), "Blizzard should work in normal weather");
    
    // Test in hail (should have perfect accuracy - this is handled by accuracy calculation system)
    state.weather = Weather::Hail;
    let result_hail = apply_blizzard(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result_hail.is_empty(), "Blizzard should work in hail");
    
    // Test in snow (should have perfect accuracy)
    state.weather = Weather::Snow;
    let result_snow = apply_blizzard(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result_snow.is_empty(), "Blizzard should work in snow");
}

#[test]
fn test_hurricane_weather_accuracy_and_confusion() {
    let framework = TestFramework::new().unwrap();
    let mut state = State::new(BattleFormat::gen9_ou());
    
    // Set up Pokemon
    let attacker = framework.create_pokemon_from_ps_data("tornadus", None, None).unwrap();
    let defender = framework.create_pokemon_from_ps_data("landorus", None, None).unwrap();
    
    state.side_one.pokemon = vec![attacker];
    state.side_one.set_active_pokemon_at_slot(0, Some(0));
    state.side_two.pokemon = vec![defender];
    state.side_two.set_active_pokemon_at_slot(0, Some(0));
    
    let move_data = EngineMoveData {
        id: 2,
        name: "Hurricane".to_string(),
        base_power: Some(110),
        accuracy: Some(70), // Base 70% accuracy
        pp: 10,
        move_type: "Flying".to_string(),
        category: tapu_simu::core::state::MoveCategory::Special,
        priority: 0,
        target: tapu_simu::data::ps_types::PSMoveTarget::Normal,
        effect_chance: Some(30),
        effect_description: "100% accuracy in rain, 50% in sun, 30% confusion".to_string(),
        flags: vec![],
    };
    
    let user_position = BattlePosition { side: SideReference::SideOne, slot: 0 };
    let target_positions = vec![BattlePosition { side: SideReference::SideTwo, slot: 0 }];
    let generation = GenerationMechanics::new(Generation::Gen9);
    
    // Test confusion effect (30% chance)
    let result = apply_hurricane(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result.is_empty(), "Hurricane should produce instructions");
    
    // Should have confusion instruction with 30% chance
    let has_confusion = result.iter().any(|si| {
        si.percentage == 30.0 && si.instruction_list.iter().any(|instr| {
            matches!(instr, tapu_simu::core::instruction::Instruction::ApplyVolatileStatus(vs_instr)
                if vs_instr.volatile_status == tapu_simu::core::instruction::VolatileStatus::Confusion)
        })
    });
    assert!(has_confusion, "Hurricane should include confusion effect with 30% chance");
}

#[test]
fn test_thunder_weather_accuracy_and_paralysis() {
    let framework = TestFramework::new().unwrap();
    let mut state = State::new(BattleFormat::gen9_ou());
    
    // Set up Pokemon
    let attacker = framework.create_pokemon_from_ps_data("raikou", None, None).unwrap();
    let defender = framework.create_pokemon_from_ps_data("gyarados", None, None).unwrap();
    
    state.side_one.pokemon = vec![attacker];
    state.side_one.set_active_pokemon_at_slot(0, Some(0));
    state.side_two.pokemon = vec![defender];
    state.side_two.set_active_pokemon_at_slot(0, Some(0));
    
    let move_data = EngineMoveData {
        id: 3,
        name: "Thunder".to_string(),
        base_power: Some(110),
        accuracy: Some(70), // Base 70% accuracy
        pp: 10,
        move_type: "Electric".to_string(),
        category: tapu_simu::core::state::MoveCategory::Special,
        priority: 0,
        target: tapu_simu::data::ps_types::PSMoveTarget::Normal,
        effect_chance: Some(30),
        effect_description: "100% accuracy in rain, 50% in sun, 30% paralysis".to_string(),
        flags: vec![],
    };
    
    let user_position = BattlePosition { side: SideReference::SideOne, slot: 0 };
    let target_positions = vec![BattlePosition { side: SideReference::SideTwo, slot: 0 }];
    let generation = GenerationMechanics::new(Generation::Gen9);
    
    // Test paralysis effect (30% chance)
    let result = apply_thunder(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result.is_empty(), "Thunder should produce instructions");
    
    // Should have paralysis instruction with 30% chance
    let has_paralysis = result.iter().any(|si| {
        si.percentage == 30.0 && si.instruction_list.iter().any(|instr| {
            matches!(instr, tapu_simu::core::instruction::Instruction::ApplyStatus(status_instr)
                if status_instr.status == PokemonStatus::Paralysis)
        })
    });
    assert!(has_paralysis, "Thunder should include paralysis effect with 30% chance");
}

#[test]
fn test_aura_wheel_morpeko_forms() {
    let framework = TestFramework::new().unwrap();
    let mut state = State::new(BattleFormat::gen9_ou());
    
    // Set up Morpeko in Full Belly mode
    let mut attacker = framework.create_pokemon_from_ps_data("morpeko", None, None).unwrap();
    attacker.species = "morpeko".to_string(); // Full Belly mode
    
    let defender = framework.create_pokemon_from_ps_data("umbreon", None, None).unwrap();
    
    state.side_one.pokemon = vec![attacker];
    state.side_one.set_active_pokemon_at_slot(0, Some(0));
    state.side_two.pokemon = vec![defender];
    state.side_two.set_active_pokemon_at_slot(0, Some(0));
    
    let move_data = EngineMoveData {
        id: 4,
        name: "Aura Wheel".to_string(),
        base_power: Some(110),
        accuracy: Some(100),
        pp: 10,
        move_type: "Electric".to_string(), // Base type
        category: tapu_simu::core::state::MoveCategory::Physical,
        priority: 0,
        target: tapu_simu::data::ps_types::PSMoveTarget::Normal,
        effect_chance: None,
        effect_description: "Type changes with Morpeko form, boosts Speed".to_string(),
        flags: vec![],
    };
    
    let user_position = BattlePosition { side: SideReference::SideOne, slot: 0 };
    let target_positions = vec![BattlePosition { side: SideReference::SideTwo, slot: 0 }];
    let generation = GenerationMechanics::new(Generation::Gen9);
    
    // Test Full Belly mode (should stay Electric type)
    let result_full_belly = apply_aura_wheel(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result_full_belly.is_empty(), "Aura Wheel should work in Full Belly mode");
    
    // Should have Speed boost
    let has_speed_boost = result_full_belly.iter().any(|si| {
        si.instruction_list.iter().any(|instr| {
            matches!(instr, tapu_simu::core::instruction::Instruction::BoostStats(boost_instr)
                if boost_instr.stat_boosts.get(&tapu_simu::core::instruction::Stat::Speed) == Some(&1))
        })
    });
    assert!(has_speed_boost, "Aura Wheel should boost Speed by 1 stage");
    
    // Test Hangry mode
    state.side_one.pokemon[0].species = "morpeko-hangry".to_string();
    let result_hangry = apply_aura_wheel(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result_hangry.is_empty(), "Aura Wheel should work in Hangry mode");
}

#[test]
fn test_raging_bull_tauros_forms() {
    let framework = TestFramework::new().unwrap();
    let mut state = State::new(BattleFormat::gen9_ou());
    
    // Set up Paldean Tauros Combat Form
    let mut attacker = framework.create_pokemon_from_ps_data("tauros", None, None).unwrap();
    attacker.species = "tauros-paldea-combat".to_string();
    
    let defender = framework.create_pokemon_from_ps_data("alakazam", None, None).unwrap();
    
    state.side_one.pokemon = vec![attacker];
    state.side_one.set_active_pokemon_at_slot(0, Some(0));
    state.side_two.pokemon = vec![defender];
    state.side_two.set_active_pokemon_at_slot(0, Some(0));
    
    // Set up Light Screen on defender's side
    state.side_two.side_conditions.insert(SideCondition::LightScreen, 5);
    
    let move_data = EngineMoveData {
        id: 5,
        name: "Raging Bull".to_string(),
        base_power: Some(90),
        accuracy: Some(100),
        pp: 10,
        move_type: "Normal".to_string(), // Base type for regular Tauros
        category: tapu_simu::core::state::MoveCategory::Physical,
        priority: 0,
        target: tapu_simu::data::ps_types::PSMoveTarget::Normal,
        effect_chance: None,
        effect_description: "Type changes with form, breaks screens".to_string(),
        flags: vec![],
    };
    
    let user_position = BattlePosition { side: SideReference::SideOne, slot: 0 };
    let target_positions = vec![BattlePosition { side: SideReference::SideTwo, slot: 0 }];
    let generation = GenerationMechanics::new(Generation::Gen9);
    
    let result = apply_raging_bull(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result.is_empty(), "Raging Bull should work");
    
    // Should have screen removal instruction
    let has_screen_removal = result.iter().any(|si| {
        si.instruction_list.iter().any(|instr| {
            matches!(instr, tapu_simu::core::instruction::Instruction::RemoveSideCondition(rsc_instr)
                if rsc_instr.condition == SideCondition::LightScreen)
        })
    });
    assert!(has_screen_removal, "Raging Bull should remove Light Screen");
}

#[test]
fn test_photon_geyser_category_determination() {
    let framework = TestFramework::new().unwrap();
    let mut state = State::new(BattleFormat::gen9_ou());
    
    // Set up Ultra Necrozma with higher Attack than Special Attack
    let mut attacker = framework.create_pokemon_from_ps_data("necrozma", None, None).unwrap();
    attacker.stats.attack = 200;
    attacker.stats.special_attack = 150;
    
    let defender = framework.create_pokemon_from_ps_data("toxapex", None, None).unwrap();
    
    state.side_one.pokemon = vec![attacker];
    state.side_one.set_active_pokemon_at_slot(0, Some(0));
    state.side_two.pokemon = vec![defender];
    state.side_two.set_active_pokemon_at_slot(0, Some(0));
    
    let move_data = EngineMoveData {
        id: 6,
        name: "Photon Geyser".to_string(),
        base_power: Some(100),
        accuracy: Some(100),
        pp: 5,
        move_type: "Psychic".to_string(),
        category: tapu_simu::core::state::MoveCategory::Special, // Base category
        priority: 0,
        target: tapu_simu::data::ps_types::PSMoveTarget::Normal,
        effect_chance: None,
        effect_description: "Physical if Attack > Special Attack".to_string(),
        flags: vec![],
    };
    
    let user_position = BattlePosition { side: SideReference::SideOne, slot: 0 };
    let target_positions = vec![BattlePosition { side: SideReference::SideTwo, slot: 0 }];
    let generation = GenerationMechanics::new(Generation::Gen9);
    
    // Test with higher Attack (should become Physical)
    let result_physical = apply_photon_geyser(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result_physical.is_empty(), "Photon Geyser should work with higher Attack");
    
    // Test with higher Special Attack (should stay Special)
    state.side_one.pokemon[0].stats.attack = 150;
    state.side_one.pokemon[0].stats.special_attack = 200;
    let result_special = apply_photon_geyser(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result_special.is_empty(), "Photon Geyser should work with higher Special Attack");
}

#[test]
fn test_sky_drop_two_turn_mechanics() {
    let framework = TestFramework::new().unwrap();
    let mut state = State::new(BattleFormat::gen9_ou());
    
    // Set up Pokemon
    let mut attacker = framework.create_pokemon_from_ps_data("aerodactyl", None, None).unwrap();
    let defender = framework.create_pokemon_from_ps_data("garchomp", None, None).unwrap();
    
    state.side_one.pokemon = vec![attacker];
    state.side_one.set_active_pokemon_at_slot(0, Some(0));
    state.side_two.pokemon = vec![defender];
    state.side_two.set_active_pokemon_at_slot(0, Some(0));
    
    let move_data = EngineMoveData {
        id: 7,
        name: "Sky Drop".to_string(),
        base_power: Some(60),
        accuracy: Some(100),
        pp: 10,
        move_type: "Flying".to_string(),
        category: tapu_simu::core::state::MoveCategory::Physical,
        priority: 0,
        target: tapu_simu::data::ps_types::PSMoveTarget::Normal,
        effect_chance: None,
        effect_description: "Two-turn move that lifts target".to_string(),
        flags: vec!["charge".to_string()],
    };
    
    let user_position = BattlePosition { side: SideReference::SideOne, slot: 0 };
    let target_positions = vec![BattlePosition { side: SideReference::SideTwo, slot: 0 }];
    let generation = GenerationMechanics::new(Generation::Gen9);
    
    // Test first turn (charging)
    let result_first_turn = apply_sky_drop(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result_first_turn.is_empty(), "Sky Drop should produce instructions on first turn");
    
    // Should apply Sky Drop status to both user and target
    let has_user_sky_drop = result_first_turn.iter().any(|si| {
        si.instruction_list.iter().any(|instr| {
            matches!(instr, tapu_simu::core::instruction::Instruction::ApplyVolatileStatus(vs_instr)
                if vs_instr.target_position == user_position && 
                   vs_instr.volatile_status == tapu_simu::core::instruction::VolatileStatus::SkyDrop)
        })
    });
    assert!(has_user_sky_drop, "Sky Drop should apply SkyDrop status to user on first turn");
    
    // Simulate having Sky Drop status for second turn
    state.side_one.pokemon[0].volatile_statuses.insert(tapu_simu::core::instruction::VolatileStatus::SkyDrop);
    let result_second_turn = apply_sky_drop(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result_second_turn.is_empty(), "Sky Drop should produce instructions on second turn");
    
    // Should remove Sky Drop status
    let has_sky_drop_removal = result_second_turn.iter().any(|si| {
        si.instruction_list.iter().any(|instr| {
            matches!(instr, tapu_simu::core::instruction::Instruction::RemoveVolatileStatus(rvs_instr)
                if rvs_instr.volatile_status == tapu_simu::core::instruction::VolatileStatus::SkyDrop)
        })
    });
    assert!(has_sky_drop_removal, "Sky Drop should remove SkyDrop status on second turn");
}

#[test]
fn test_mortal_spin_hazard_removal_and_poison() {
    let framework = TestFramework::new().unwrap();
    let mut state = State::new(BattleFormat::gen9_ou());
    
    // Set up Pokemon
    let attacker = framework.create_pokemon_from_ps_data("forretress", None, None).unwrap();
    let defender = framework.create_pokemon_from_ps_data("garchomp", None, None).unwrap();
    
    state.side_one.pokemon = vec![attacker];
    state.side_one.set_active_pokemon_at_slot(0, Some(0));
    state.side_two.pokemon = vec![defender];
    state.side_two.set_active_pokemon_at_slot(0, Some(0));
    
    // Set up hazards on user's side
    state.side_one.side_conditions.insert(SideCondition::Spikes, 3);
    state.side_one.side_conditions.insert(SideCondition::StealthRock, 1);
    
    let move_data = EngineMoveData {
        id: 8,
        name: "Mortal Spin".to_string(),
        base_power: Some(30),
        accuracy: Some(100),
        pp: 15,
        move_type: "Poison".to_string(),
        category: tapu_simu::core::state::MoveCategory::Physical,
        priority: 0,
        target: tapu_simu::data::ps_types::PSMoveTarget::Normal,
        effect_chance: None,
        effect_description: "Removes hazards, poisons adjacent opponents".to_string(),
        flags: vec![],
    };
    
    let user_position = BattlePosition { side: SideReference::SideOne, slot: 0 };
    let target_positions = vec![BattlePosition { side: SideReference::SideTwo, slot: 0 }];
    let generation = GenerationMechanics::new(Generation::Gen9);
    
    let result = apply_mortal_spin(&state, &move_data, user_position, &target_positions, &generation);
    assert!(!result.is_empty(), "Mortal Spin should produce instructions");
    
    // Should have hazard removal instructions
    let has_spikes_removal = result.iter().any(|si| {
        si.instruction_list.iter().any(|instr| {
            matches!(instr, tapu_simu::core::instruction::Instruction::RemoveSideCondition(rsc_instr)
                if rsc_instr.condition == SideCondition::Spikes && rsc_instr.side == SideReference::SideOne)
        })
    });
    assert!(has_spikes_removal, "Mortal Spin should remove Spikes from user's side");
    
    // Should have poison instruction for opponents
    let has_poison = result.iter().any(|si| {
        si.instruction_list.iter().any(|instr| {
            matches!(instr, tapu_simu::core::instruction::Instruction::ApplyStatus(status_instr)
                if status_instr.status == PokemonStatus::Poison)
        })
    });
    assert!(has_poison, "Mortal Spin should poison adjacent opponents");
}