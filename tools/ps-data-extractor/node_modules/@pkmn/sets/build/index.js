"use strict";Object.defineProperty(exports, "__esModule", {value: true});// src/sets.ts
function toID(s) {
  if (typeof s !== "string" && typeof s !== "number")
    return "";
  return ("" + s).toLowerCase().replace(/[^a-z0-9]+/g, "");
}
var STAT_NAMES = {
  hp: "HP",
  atk: "Atk",
  def: "Def",
  spa: "SpA",
  spd: "SpD",
  spe: "Spe"
};
var STATS = Object.keys(STAT_NAMES);
var DECODE_STAT = {
  HP: "hp",
  hp: "hp",
  Attack: "atk",
  Atk: "atk",
  atk: "atk",
  Defense: "def",
  Def: "def",
  def: "def",
  "Special Attack": "spa",
  SpA: "spa",
  SAtk: "spa",
  SpAtk: "spa",
  spa: "spa",
  Special: "spa",
  spc: "spa",
  Spc: "spa",
  "Special Defense": "spd",
  SpD: "spd",
  SDef: "spd",
  SpDef: "spd",
  spd: "spd",
  Speed: "spe",
  Spe: "spe",
  Spd: "spe",
  spe: "spe"
};
var Sets = new class {
  pack(s) {
    return Sets.packSet(s);
  }
  packSet(s) {
    let buf = "";
    buf += s.name || s.species;
    const packed = packName(s.species);
    buf += "|" + (packName(s.name || s.species) === packed ? "" : packed);
    buf += "|" + packName(s.item);
    buf += "|" + (packName(s.ability) || "-");
    let hasHP = "";
    buf += "|";
    if (s.moves) {
      for (let j = 0; j < s.moves.length; j++) {
        const packedMove = packName(s.moves[j]);
        if (j && !packedMove)
          continue;
        buf += (j ? "," : "") + packedMove;
        if (packedMove.substr(0, 11) === "HiddenPower" && packedMove.length > 11) {
          hasHP = packedMove.slice(11);
        }
      }
    }
    buf += "|" + (s.nature || "");
    let evs = "|";
    if (s.evs) {
      evs = "|" + (s.evs["hp"] || "") + "," + (s.evs["atk"] || "") + "," + (s.evs["def"] || "") + "," + (s.evs["spa"] || "") + "," + (s.evs["spd"] || "") + "," + (s.evs["spe"] || "");
    }
    if (evs === "|,,,,,") {
      buf += "|";
    } else {
      buf += evs;
    }
    if (s.gender) {
      buf += "|" + s.gender;
    } else {
      buf += "|";
    }
    const getIV = (stat) => !("ivs" in s) || s.ivs[stat] === 31 || s.ivs[stat] === void 0 ? "" : s.ivs[stat].toString();
    let ivs = "|";
    if (s.ivs) {
      ivs = "|" + getIV("hp") + "," + getIV("atk") + "," + getIV("def") + "," + getIV("spa") + "," + getIV("spd") + "," + getIV("spe");
    }
    if (ivs === "|,,,,,") {
      buf += "|";
    } else {
      buf += ivs;
    }
    if (s.shiny) {
      buf += "|S";
    } else {
      buf += "|";
    }
    if (s.level && s.level !== 100) {
      buf += "|" + s.level;
    } else {
      buf += "|";
    }
    if (s.happiness !== void 0 && s.happiness !== 255) {
      buf += "|" + s.happiness;
    } else {
      buf += "|";
    }
    const dynamax = s.dynamaxLevel !== void 0 && s.dynamaxLevel !== 10;
    if (s.pokeball || s.hpType && !hasHP || s.gigantamax || dynamax || s.teraType) {
      buf += "," + (s.hpType || "");
      buf += "," + packName(s.pokeball || "");
      buf += "," + (s.gigantamax ? "G" : "");
      buf += "," + (dynamax ? s.dynamaxLevel : "");
      buf += "," + (s.teraType || "");
    }
    return buf;
  }
  exportSet(s, data) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    let buf = "";
    let species = s.species || s.name || "";
    species = ((_a = data == null ? void 0 : data.species.get(species)) == null ? void 0 : _a.name) || species;
    if (s.name && s.name !== species) {
      buf += "" + s.name + " (" + species + ")";
    } else {
      buf += "" + species;
    }
    if (!data || data.gen >= 2) {
      if (s.gender === "M")
        buf += " (M)";
      if (s.gender === "F")
        buf += " (F)";
    }
    if (s.item) {
      const item = (_c = (_b = data == null ? void 0 : data.items.get(s.item)) == null ? void 0 : _b.name) != null ? _c : s.item;
      buf += " @ " + item;
    }
    buf += "  \n";
    if (s.ability && (!data || (data == null ? void 0 : data.gen) >= 3)) {
      const ability = (_e = (_d = data == null ? void 0 : data.abilities.get(s.ability)) == null ? void 0 : _d.name) != null ? _e : s.ability;
      buf += "Ability: " + ability + "  \n";
    }
    if (s.level && s.level !== 100) {
      buf += "Level: " + s.level + "  \n";
    }
    if (s.shiny && (!data || data.gen >= 2)) {
      buf += "Shiny: Yes  \n";
    }
    if (typeof s.happiness === "number" && s.happiness !== 255 && !isNaN(s.happiness) && (!data || data.gen >= 2)) {
      buf += "Happiness: " + s.happiness + "  \n";
    }
    if (s.pokeball) {
      buf += "Pokeball: " + s.pokeball + "  \n";
    }
    if (s.hpType) {
      buf += "Hidden Power: " + s.hpType + "  \n";
    }
    if (typeof s.dynamaxLevel === "number" && s.dynamaxLevel !== 10 && !isNaN(s.dynamaxLevel)) {
      buf += "Dynamax Level: " + s.dynamaxLevel + "  \n";
    }
    if (s.gigantamax) {
      buf += "Gigantamax: Yes  \n";
    }
    if (s.teraType) {
      const d = data == null ? void 0 : data.species.get(species);
      buf += "Tera Type: " + ((d == null ? void 0 : d.forceTeraType) || s.teraType || ((_f = d == null ? void 0 : d.types) == null ? void 0 : _f[0])) + "  \n";
    }
    let first = true;
    if (s.evs && (!data || data.gen >= 3)) {
      for (const stat of STATS) {
        if (!s.evs[stat])
          continue;
        if (first) {
          buf += "EVs: ";
          first = false;
        } else {
          buf += " / ";
        }
        buf += "" + s.evs[stat] + " " + STAT_NAMES[stat];
      }
    }
    if (!first) {
      buf += "  \n";
    }
    if (s.nature && (!data || data.gen >= 3)) {
      buf += "" + s.nature + " Nature  \n";
    }
    first = true;
    if (s.ivs) {
      let defaultIVs = true;
      let hpType = void 0;
      if (s.moves) {
        for (const move of s.moves) {
          hpType = getHiddenPowerType(move);
          if (hpType) {
            const hpIVs = getHiddenPowerIVs(hpType, data);
            if (!hpIVs)
              continue;
            for (const stat of STATS) {
              if ((s.ivs[stat] === void 0 ? 31 : s.ivs[stat]) !== (hpIVs[stat] || 31)) {
                defaultIVs = false;
                break;
              }
            }
          }
        }
      }
      if (defaultIVs && !hpType) {
        for (const stat of STATS) {
          if (s.ivs[stat] !== 31 && s.ivs[stat] !== void 0) {
            defaultIVs = false;
            break;
          }
        }
      }
      if (!defaultIVs) {
        for (const stat of STATS) {
          if (typeof s.ivs[stat] === "undefined" || isNaN(s.ivs[stat]) || s.ivs[stat] === 31) {
            continue;
          }
          if (first) {
            buf += "IVs: ";
            first = false;
          } else {
            buf += " / ";
          }
          buf += "" + s.ivs[stat] + " " + STAT_NAMES[stat];
        }
      }
    }
    if (!first) {
      buf += "  \n";
    }
    if (s.moves) {
      for (let move of s.moves) {
        if (move) {
          move = (_h = (_g = data == null ? void 0 : data.moves.get(move)) == null ? void 0 : _g.name) != null ? _h : move;
          buf += "- " + exportMove(move) + "  \n";
        }
      }
    }
    buf += "\n";
    return buf;
  }
  unpack(buf, data) {
    return Sets.unpackSet(buf, data);
  }
  unpackSet(buf, data) {
    return _unpack(buf, 0, 0, data).set;
  }
  importSet(buf, data) {
    return _import(buf.split("\n"), 0, data).set;
  }
  toJSON(s) {
    return JSON.stringify(s);
  }
  fromJSON(json) {
    if (!json.startsWith("{") || !json.endsWith("}"))
      return void 0;
    return JSON.parse(json);
  }
  toString(s, data) {
    return Sets.exportSet(s, data);
  }
  fromString(str) {
    return Sets.importSet(str);
  }
  // NOTE: to properly dedupe you still must compare computed stats
  canonicalize(s, data) {
    var _a, _b, _c;
    const species = data.species.get(s.species);
    s.species = toID(species.battleOnly ? species.baseSpecies : species.name);
    s.name = void 0;
    s.item = data.gen >= 2 && s.item ? toID(s.item) : void 0;
    s.ability = data.gen >= 3 ? toID(s.ability ? s.ability : species.abilities[0]) : void 0;
    s.gender = data.gen >= 2 && s.gender && s.gender !== species.gender ? s.gender : void 0;
    s.level = s.level || 100;
    let maxed = true;
    if (!s.ivs) {
      s.ivs = { hp: 31, atk: 31, def: 31, spa: 31, spd: 31, spe: 31 };
    } else {
      for (const stat of STATS) {
        s.ivs[stat] = (_a = s.ivs[stat]) != null ? _a : 31;
        if (data.gen < 3)
          s.ivs[stat] = toIV(toDV(s.ivs[stat]));
        if (s.ivs[stat] !== 31)
          maxed = false;
      }
    }
    const nature = data.gen < 3 ? void 0 : data.natures.get(s.nature || "serious");
    s.nature = nature && toID(nature.name);
    let hpType = s.hpType;
    let happiness = "";
    let swordsdance = false;
    const moves = [];
    for (const move of s.moves) {
      let id = toID(move);
      if (id === "return" || id === "frustration") {
        happiness = id;
      } else if (id === "swordsdance") {
        swordsdance = true;
      } else if (id.startsWith("hiddenpower")) {
        if (id === "hiddenpower") {
          const type = s.hpType || getHiddenPower(data.gen, s.ivs).type;
          id = `${id}${type}`;
        } else {
          hpType = id.substr(11, 1).toUpperCase() + id.substr(12);
        }
      }
      moves.push(id);
    }
    s.moves = moves.sort((a, b) => a.localeCompare(b));
    const base = data.species.get(s.species).baseStats;
    s.evs = s.evs || {};
    for (const stat of STATS) {
      if (data.gen < 3) {
        s.evs[stat] = (_b = s.evs[stat]) != null ? _b : 252;
      } else {
        if (!s.evs[stat]) {
          s.evs[stat] = 0;
        } else {
          const val = calc(data.gen, stat, base[stat], s.ivs[stat], s.evs[stat], s.level, nature);
          if (stat === "hp") {
            s.evs[stat] = base[stat] === 1 ? 0 : Math.max(0, (Math.ceil((val - s.level - 10) * 100 / s.level) - 2 * base[stat] - s.ivs[stat]) * 4);
          } else {
            const n = !nature ? 1 : nature.plus === stat ? 1.1 : nature.minus === stat ? 0.9 : 1;
            s.evs[stat] = Math.max(0, (Math.ceil((Math.ceil(val / n) - 5) * 100 / s.level) - 2 * base[stat] - s.ivs[stat]) * 4);
          }
        }
      }
    }
    if (data.gen === 2 && s.species === "marowak" && s.item === "thickclub" && swordsdance && s.level === 100) {
      const iv = Math.floor(s.ivs.atk / 2) * 2;
      while (s.evs.atk > 0 && 2 * 80 + iv + Math.floor(s.evs.atk / 4) + 5 > 255) {
        s.evs.atk -= 4;
      }
    }
    const canBottle = data.gen >= 7 && s.level === 100;
    if (hpType && maxed) {
      const ivs = data.gen === 2 ? HP[hpType].dvs : HP[hpType].ivs;
      for (const stat of STATS) {
        if (data.gen === 2) {
          s.ivs[stat] = stat in ivs ? toIV(ivs[stat]) : 31;
        } else if (!canBottle) {
          s.ivs[stat] = (_c = ivs[stat]) != null ? _c : 31;
        }
      }
      if (data.gen === 2)
        s.ivs.hp = toIV(getHPDV(s.ivs));
    }
    s.hpType = hpType && canBottle ? hpType : void 0;
    if (happiness === "return") {
      s.happiness = 255;
    } else if (happiness === "frustration") {
      s.happiness = 0;
    } else {
      s.happiness = void 0;
    }
    s.shiny = data.gen >= 2 && s.shiny ? s.shiny : void 0;
    s.pokeball = void 0;
    s.dynamaxLevel = data.gen === 8 ? s.dynamaxLevel : void 0;
    s.gigantamax = data.gen === 8 && s.gigantamax ? s.gigantamax : void 0;
    s.teraType = data.gen === 9 ? s.teraType : void 0;
    return s;
  }
}();
var ABILITY = ["", "0", "1", "H", "S"];
function _unpack(buf, i = 0, j = 0, data) {
  const s = {};
  j = buf.indexOf("|", i);
  if (j < 0)
    return { i, j };
  s.name = buf.substring(i, j);
  i = j + 1;
  j = buf.indexOf("|", i);
  if (j < 0)
    return { i, j };
  s.species = unpackName(buf.substring(i, j), data == null ? void 0 : data.species) || s.name;
  i = j + 1;
  j = buf.indexOf("|", i);
  if (j < 0)
    return { i, j };
  s.item = unpackName(buf.substring(i, j), data == null ? void 0 : data.items);
  i = j + 1;
  j = buf.indexOf("|", i);
  if (j < 0)
    return { i, j };
  let ability = unpackName(buf.substring(i, j), data == null ? void 0 : data.abilities);
  if (ability === "-") {
    ability = "";
  } else if (ABILITY.includes(ability)) {
    if (data) {
      const species = data.species.get(s.species);
      if ((species == null ? void 0 : species.baseSpecies) === "Zygarde" && ability === "H") {
        ability = "Power Construct";
      } else if (species == null ? void 0 : species.abilities) {
        ability = species.abilities[ability || "0"];
      }
    }
    if (ability !== "" && !ability)
      return { i, j };
  }
  s.ability = ability;
  i = j + 1;
  j = buf.indexOf("|", i);
  if (j < 0)
    return { i, j };
  s.moves = buf.substring(i, j).split(",", 24).filter((x) => x).map((m) => unpackName(m, data == null ? void 0 : data.moves));
  i = j + 1;
  j = buf.indexOf("|", i);
  if (j < 0)
    return { i, j };
  s.nature = unpackName(buf.substring(i, j), data == null ? void 0 : data.natures);
  i = j + 1;
  j = buf.indexOf("|", i);
  if (j < 0)
    return { i, j };
  s.evs = { hp: 0, atk: 0, def: 0, spa: 0, spd: 0, spe: 0 };
  if (j !== i) {
    const evstr = buf.substring(i, j);
    if (evstr.length > 5) {
      const st = evstr.split(",");
      s.evs.hp = Number(st[0]) || s.evs.hp;
      s.evs.atk = Number(st[1]) || s.evs.atk;
      s.evs.def = Number(st[2]) || s.evs.def;
      s.evs.spa = Number(st[3]) || s.evs.spa;
      s.evs.spd = Number(st[4]) || s.evs.spd;
      s.evs.spe = Number(st[5]) || s.evs.spe;
    }
  }
  i = j + 1;
  j = buf.indexOf("|", i);
  if (j < 0)
    return { i, j };
  if (i !== j)
    s.gender = buf.substring(i, j);
  i = j + 1;
  j = buf.indexOf("|", i);
  if (j < 0)
    return { i, j };
  s.ivs = { hp: 31, atk: 31, def: 31, spa: 31, spd: 31, spe: 31 };
  if (j !== i) {
    const st = buf.substring(i, j).split(",", 6);
    s.ivs.hp = st[0] === "" ? 31 : Number(st[0]) || 0;
    s.ivs.atk = st[1] === "" ? 31 : Number(st[1]) || 0;
    s.ivs.def = st[2] === "" ? 31 : Number(st[2]) || 0;
    s.ivs.spa = st[3] === "" ? 31 : Number(st[3]) || 0;
    s.ivs.spd = st[4] === "" ? 31 : Number(st[4]) || 0;
    s.ivs.spe = st[5] === "" ? 31 : Number(st[5]) || 0;
  }
  i = j + 1;
  j = buf.indexOf("|", i);
  if (j < 0)
    return { i, j };
  if (i !== j)
    s.shiny = true;
  i = j + 1;
  j = buf.indexOf("|", i);
  if (j < 0)
    return { i, j };
  if (i !== j)
    s.level = parseInt(buf.substring(i, j));
  i = j + 1;
  j = buf.indexOf("]", i);
  let misc;
  if (j < 0) {
    if (i < buf.length)
      misc = buf.substring(i).split(",", 6);
  } else {
    if (i !== j)
      misc = buf.substring(i, j).split(",", 6);
  }
  if (misc) {
    s.happiness = misc[0] ? Number(misc[0]) : 255;
    s.hpType = misc[1] || "";
    s.pokeball = unpackName(misc[2] || "", data == null ? void 0 : data.items);
    s.gigantamax = !!misc[3];
    s.dynamaxLevel = misc[4] ? Number(misc[4]) : 10;
    s.teraType = misc[5] || "";
  }
  return { set: s, i, j };
}
var NATURE_REGEX = /^[A-Za-z]+ (N|n)ature/;
function _import(lines, i = 0, data) {
  var _a, _b, _c, _d;
  let s = void 0;
  for (; i < lines.length; i++) {
    let line = lines[i].trim();
    if (line === "" || line === "---" || line.substr(0, 3) === "===" || line.includes("|")) {
      return { set: s, line: i };
    } else if (!s) {
      s = { name: "", species: "", gender: "" };
      const atIndex = line.lastIndexOf(" @ ");
      if (atIndex !== -1) {
        s.item = line.substr(atIndex + 3);
        if (toID(s.item) === "noitem")
          s.item = "";
        line = line.substr(0, atIndex);
      }
      if (line.substr(line.length - 4) === " (M)") {
        s.gender = "M";
        line = line.substr(0, line.length - 4);
      }
      if (line.substr(line.length - 4) === " (F)") {
        s.gender = "F";
        line = line.substr(0, line.length - 4);
      }
      const parenIndex = line.lastIndexOf(" (");
      if (line.substr(line.length - 1) === ")" && parenIndex !== -1) {
        line = line.substr(0, line.length - 1);
        const sub = line.substr(parenIndex + 2);
        s.species = (_b = (_a = data == null ? void 0 : data.species.get(sub)) == null ? void 0 : _a.name) != null ? _b : sub;
        line = line.substr(0, parenIndex);
        s.name = line;
      } else {
        s.species = (_d = (_c = data == null ? void 0 : data.species.get(line)) == null ? void 0 : _c.name) != null ? _d : line;
        s.name = "";
      }
    } else if (line.substr(0, 7) === "Trait: ") {
      line = line.substr(7);
      s.ability = line;
    } else if (line.substr(0, 9) === "Ability: ") {
      line = line.substr(9);
      s.ability = line;
    } else if (line === "Shiny: Yes") {
      s.shiny = true;
    } else if (line.substr(0, 7) === "Level: ") {
      line = line.substr(7);
      s.level = +line;
    } else if (line.substr(0, 11) === "Happiness: ") {
      line = line.substr(11);
      s.happiness = +line;
    } else if (line.substr(0, 10) === "Pokeball: ") {
      line = line.substr(10);
      s.pokeball = line;
    } else if (line.substr(0, 14) === "Hidden Power: ") {
      line = line.substr(14);
      s.hpType = line;
    } else if (line.substr(0, 11) === "Tera Type: ") {
      line = line.substr(11);
      s.teraType = line;
    } else if (line.substr(0, 15) === "Dynamax Level: ") {
      line = line.substr(15);
      s.dynamaxLevel = +line;
    } else if (line === "Gigantamax: Yes") {
      s.gigantamax = true;
    } else if (line.substr(0, 5) === "EVs: ") {
      line = line.substr(5);
      const evLines = line.split(" / ");
      s.evs = { hp: 0, atk: 0, def: 0, spa: 0, spd: 0, spe: 0 };
      for (const evLine of evLines) {
        const spaceIndex = evLine.indexOf(" ");
        if (spaceIndex === -1)
          continue;
        const stat = DECODE_STAT[evLine.substr(spaceIndex + 1)];
        const val = parseInt(evLine.substr(0, spaceIndex));
        if (!stat)
          continue;
        s.evs[stat] = val;
      }
    } else if (line.substr(0, 5) === "IVs: ") {
      line = line.substr(5);
      const ivLines = line.split(" / ");
      s.ivs = { hp: 31, atk: 31, def: 31, spa: 31, spd: 31, spe: 31 };
      for (const ivLine of ivLines) {
        const spaceIndex = ivLine.indexOf(" ");
        if (spaceIndex === -1)
          continue;
        const stat = DECODE_STAT[ivLine.substr(spaceIndex + 1)];
        let val = parseInt(ivLine.substr(0, spaceIndex));
        if (!stat)
          continue;
        if (isNaN(val))
          val = 31;
        s.ivs[stat] = val;
      }
    } else if (NATURE_REGEX.exec(line)) {
      let natureIndex = line.indexOf(" Nature");
      if (natureIndex === -1)
        natureIndex = line.indexOf(" nature");
      line = line.substr(0, natureIndex);
      if (line !== "undefined")
        s.nature = line;
    } else if (line.substr(0, 1) === "-" || line.substr(0, 1) === "~") {
      line = line.substr(1);
      if (line.substr(0, 1) === " ")
        line = line.substr(1);
      if (!s.moves)
        s.moves = [];
      const hpType = getHiddenPowerType(line);
      if (hpType) {
        line = "Hidden Power " + hpType.toString();
        const hpIVs = getHiddenPowerIVs(hpType, data);
        if (!s.ivs && hpIVs) {
          s.ivs = { hp: 31, atk: 31, def: 31, spa: 31, spd: 31, spe: 31 };
          let stat;
          for (stat in hpIVs) {
            s.ivs[stat] = hpIVs[stat];
          }
        }
      }
      if (line === "Frustration" && s.happiness === void 0) {
        s.happiness = 0;
      }
      s.moves.push(line);
    }
  }
  return { set: s, line: i + 1 };
}
function getHiddenPowerType(move) {
  if (move.substr(0, 14) === "Hidden Power [") {
    return move.substr(14, move.length - 15);
  }
  if (move.substr(0, 13) === "Hidden Power ") {
    return move.substr(13);
  }
  if (move.substr(0, 11) === "hiddenpower") {
    return move.substr(11, 1).toUpperCase() + move.substr(12);
  }
  return void 0;
}
function exportMove(move) {
  if (move.substr(0, 14) === "Hidden Power [") {
    return move;
  }
  if (move.substr(0, 13) === "Hidden Power ") {
    return move.substr(0, 13) + "[" + move.substr(13) + "]";
  }
  if (move.substr(0, 11) === "hiddenpower") {
    return "Hidden Power [" + move.substr(11, 1).toUpperCase() + move.substr(12) + "]";
  }
  return move;
}
function packName(name) {
  if (!name)
    return "";
  return name.replace(/[^A-Za-z0-9]+/g, "");
}
function unpackName(name, data) {
  if (!name)
    return "";
  if (data) {
    const obj = data.get(name);
    if (obj == null ? void 0 : obj.exists)
      return obj.name;
  }
  return name.replace(/([0-9]+)/g, " $1 ").replace(/([A-Z])/g, " $1").replace(/[ ][ ]/g, " ").trim();
}
var HP = {
  Bug: { ivs: { atk: 30, def: 30, spd: 30 }, dvs: { atk: 13, def: 13 } },
  Dark: { ivs: {}, dvs: {} },
  Dragon: { ivs: { atk: 30 }, dvs: { def: 14 } },
  Electric: { ivs: { spa: 30 }, dvs: { atk: 14 } },
  Fighting: { ivs: { def: 30, spa: 30, spd: 30, spe: 30 }, dvs: { atk: 12, def: 12 } },
  Fire: { ivs: { atk: 30, spa: 30, spe: 30 }, dvs: { atk: 14, def: 12 } },
  Flying: { ivs: { hp: 30, atk: 30, def: 30, spa: 30, spd: 30 }, dvs: { atk: 12, def: 13 } },
  Ghost: { ivs: { def: 30, spd: 30 }, dvs: { atk: 13, def: 14 } },
  Grass: { ivs: { atk: 30, spa: 30 }, dvs: { atk: 14, def: 14 } },
  Ground: { ivs: { spa: 30, spd: 30 }, dvs: { atk: 12 } },
  Ice: { ivs: { atk: 30, def: 30 }, dvs: { def: 13 } },
  Poison: { ivs: { def: 30, spa: 30, spd: 30 }, dvs: { atk: 12, def: 14 } },
  Psychic: { ivs: { atk: 30, spe: 30 }, dvs: { def: 12 } },
  Rock: { ivs: { def: 30, spd: 30, spe: 30 }, dvs: { atk: 13, def: 12 } },
  Steel: { ivs: { spd: 30 }, dvs: { atk: 13 } },
  Water: { ivs: { atk: 30, def: 30, spa: 30 }, dvs: { atk: 14, def: 13 } }
};
var HP_TYPES = [
  "Fighting",
  "Flying",
  "Poison",
  "Ground",
  "Rock",
  "Bug",
  "Ghost",
  "Steel",
  "Fire",
  "Water",
  "Grass",
  "Electric",
  "Psychic",
  "Ice",
  "Dragon",
  "Dark"
];
function getHiddenPower(gen, ivs) {
  const tr2 = (num, bits = 0) => {
    if (bits)
      return (num >>> 0) % 2 ** bits;
    return num >>> 0;
  };
  const stats = { hp: 31, atk: 31, def: 31, spe: 31, spa: 31, spd: 31 };
  if (gen <= 2) {
    const atkDV = tr2(ivs.atk / 2);
    const defDV = tr2(ivs.def / 2);
    const speDV = tr2(ivs.spe / 2);
    const spcDV = tr2(ivs.spa / 2);
    return {
      type: HP_TYPES[4 * (atkDV % 4) + defDV % 4],
      power: tr2(
        (5 * ((spcDV >> 3) + 2 * (speDV >> 3) + 4 * (defDV >> 3) + 8 * (atkDV >> 3)) + spcDV % 4) / 2 + 31
      )
    };
  } else {
    let hpTypeX = 0;
    let hpPowerX = 0;
    let i = 1;
    for (const s in stats) {
      hpTypeX += i * (ivs[s] % 2);
      hpPowerX += i * (tr2(ivs[s] / 2) % 2);
      i *= 2;
    }
    return {
      type: HP_TYPES[tr2(hpTypeX * 15 / 63)],
      // After Gen 6, Hidden Power is always 60 base power
      power: gen < 6 ? tr2(hpPowerX * 40 / 63) + 30 : 60
    };
  }
}
function getHiddenPowerIVs(hpType, data) {
  const hp = HP[hpType];
  if (!hp)
    return void 0;
  return (data == null ? void 0 : data.gen) === 2 ? DVsToIVs(hp.dvs) : hp.ivs;
}
function DVsToIVs(dvs) {
  const ivs = {};
  let dv;
  for (dv in dvs)
    ivs[dv] = toIV(dvs[dv]);
  return ivs;
}
function toDV(iv) {
  return Math.floor(iv / 2);
}
function toIV(dv) {
  return dv * 2 + 1;
}
function getHPDV(ivs) {
  return toDV(ivs.atk === void 0 ? 31 : ivs.atk) % 2 * 8 + toDV(ivs.def === void 0 ? 31 : ivs.def) % 2 * 4 + toDV(ivs.spe === void 0 ? 31 : ivs.spe) % 2 * 2 + toDV(ivs.spa === void 0 ? 31 : ivs.spa) % 2;
}
var tr = (num, bits = 0) => bits ? (num >>> 0) % 2 ** bits : num >>> 0;
function calc(gen, stat, base, iv = 31, ev, level = 100, nature) {
  if (ev === void 0)
    ev = gen < 3 ? 252 : 0;
  if (gen < 3) {
    iv = toDV(iv) * 2;
    nature = void 0;
  }
  if (stat === "hp") {
    return base === 1 ? base : tr(tr(2 * base + iv + tr(ev / 4) + 100) * level / 100 + 10);
  } else {
    const val = tr(tr(2 * base + iv + tr(ev / 4)) * level / 100 + 5);
    if (nature !== void 0) {
      if (nature.plus === stat)
        return tr(tr(val * 110, 16) / 100);
      if (nature.minus === stat)
        return tr(tr(val * 90, 16) / 100);
    }
    return val;
  }
}

// src/teams.ts
var CURRENT = 9;
var Team = class _Team {
  constructor(team, data, format, name, folder) {
    this.team = team;
    this.data = data;
    this.format = format;
    this.name = name;
    this.folder = folder;
    this.team = team;
    this.format = format;
    this.name = name;
    this.folder = folder;
    this.data = data;
    if (format && (data == null ? void 0 : data.forGen)) {
      if (format.slice(0, 3) === "gen") {
        this.data = data.forGen(parseInt(format[3]));
      } else {
        this.format = `gen6${format}`;
        this.data = data.forGen(6);
      }
    }
  }
  get gen() {
    var _a;
    return (_a = this.data) == null ? void 0 : _a.gen;
  }
  pack() {
    return Teams.packTeam(this);
  }
  static unpack(buf, data) {
    return Teams.unpackTeam(buf, data);
  }
  export(data) {
    let buf = "";
    for (const s of this.team) {
      buf += Sets.exportSet(s, data || this.data);
    }
    return buf;
  }
  static import(buf, data) {
    return Teams.importTeam(buf, data);
  }
  toString(data) {
    return this.export(data);
  }
  static fromString(str, data) {
    const teams = Teams.importTeams(str, data, true, true);
    return teams.length ? teams[0] : void 0;
  }
  toJSON() {
    return JSON.stringify(this.team);
  }
  static fromJSON(json) {
    if (json.charAt(0) !== "[" || json.charAt(json.length - 1) !== "]") {
      return void 0;
    }
    const team = JSON.parse(json);
    return new _Team(team);
  }
  static canonicalize(team, data) {
    let lead = void 0;
    const rest = [];
    for (const s of team) {
      const set = Sets.canonicalize(s, data);
      if (lead) {
        rest.push([set.species, set]);
      } else {
        lead = set;
      }
    }
    return [lead, ...rest.sort((a, b) => a[0].localeCompare(b[0])).map(([, set]) => set)];
  }
};
var Teams = new class {
  packTeam(team) {
    let buf = "";
    for (const s of team.team) {
      if (buf)
        buf += "]";
      buf += Sets.packSet(s);
    }
    return buf;
  }
  unpackTeam(buf, data) {
    if (!buf)
      return void 0;
    if (buf.charAt(0) === "[" && buf.charAt(buf.length - 1) === "]") {
      return Team.fromJSON(buf);
    }
    const team = [];
    let i = 0, j = 0;
    for (let k = 0; k < 24; k++) {
      const r = _unpack(buf, i, j, data);
      if (!r.set)
        return void 0;
      team.push(r.set);
      i = r.i;
      j = r.j;
      if (j < 0)
        break;
      i = j + 1;
    }
    return new Team(team, data);
  }
  importTeam(buf, data) {
    const teams = Teams.importTeams(buf, data, true);
    return teams.length ? teams[0] : void 0;
  }
  importTeams(buf, data, one, builder) {
    const lines = buf.split("\n");
    if (lines.length === 1 || lines.length === 2 && !lines[1]) {
      const team2 = builder ? unpackLine(lines[0], data) : Teams.unpackTeam(lines[0], data);
      return team2 ? [team2] : [];
    }
    const teams = [];
    let setLine = -1;
    let team = [];
    for (let i = 0; i < lines.length; i++) {
      let line = lines[i].trim();
      if (line.substr(0, 3) === "===") {
        if (one && teams.length)
          return teams;
        team = [];
        line = line.substr(3, line.length - 6).trim();
        let format = `gen${(data == null ? void 0 : data.gen) || CURRENT}`;
        const bracketIndex = line.indexOf("]");
        if (bracketIndex >= 0) {
          format = line.substr(1, bracketIndex - 1);
          line = line.substr(bracketIndex + 1).trim();
        }
        const slashIndex = line.lastIndexOf("/");
        let folder = "";
        if (slashIndex > 0) {
          folder = line.slice(0, slashIndex);
          line = line.slice(slashIndex + 1);
        }
        teams.push(new Team(team, data, format, line, folder));
      } else if (line.includes("|")) {
        const t = unpackLine(line, data);
        if (t)
          teams.push(t);
      } else if (setLine !== i) {
        const r = _import(lines, i, data);
        if (r.set)
          team.push(r.set);
        if (r.line === i) {
          continue;
        }
        setLine = r.line;
        i = setLine - 1;
      }
    }
    if (team.length && !teams.length) {
      teams.push(new Team(team, data));
    }
    return teams;
  }
  exportTeams(teams, data) {
    let buf = "";
    let i = 0;
    for (const team of teams) {
      buf += "=== " + (team.format ? "[" + team.format.toString() + "] " : "") + (team.folder ? "" + team.folder + "/" : "") + (team.name || "Untitled " + ++i) + " ===\n\n";
      buf += team.export(data);
      buf += "\n";
    }
    return buf;
  }
  toString(teams, data) {
    return Teams.exportTeams(teams, data);
  }
  fromString(str, data) {
    return Teams.importTeams(str, data, false, true);
  }
}();
function unpackLine(line, data) {
  const pipeIndex = line.indexOf("|");
  if (pipeIndex < 0)
    return void 0;
  let bracketIndex = line.indexOf("]");
  if (bracketIndex > pipeIndex)
    bracketIndex = -1;
  let slashIndex = line.lastIndexOf("/", pipeIndex);
  if (slashIndex < 0)
    slashIndex = bracketIndex;
  const format = bracketIndex > 0 ? line.slice(0, bracketIndex) : `gen${(data == null ? void 0 : data.gen) || CURRENT}`;
  const team = Teams.unpackTeam(line.slice(pipeIndex + 1), data);
  return !team ? team : new Team(
    team.team,
    data,
    format,
    line.slice(slashIndex + 1, pipeIndex),
    line.slice(
      bracketIndex + 1,
      slashIndex > 0 ? slashIndex : bracketIndex + 1
    )
  );
}




exports.Sets = Sets; exports.Team = Team; exports.Teams = Teams;
//# sourceMappingURL=index.js.map