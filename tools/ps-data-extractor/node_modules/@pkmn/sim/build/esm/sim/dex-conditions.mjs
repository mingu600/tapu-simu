import { BasicEffect, toID } from './dex-data.mjs';
export class Condition extends BasicEffect {
    constructor(data) {
        super(data);
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        data = this;
        this.effectType = (['Weather', 'Status'].includes(data.effectType) ? data.effectType : 'Condition');
    }
}
const EMPTY_CONDITION = new Condition({ name: '', exists: false });
export class DexConditions {
    constructor(dex) {
        this.conditionCache = new Map();
        this.dex = dex;
    }
    get(name) {
        if (!name)
            return EMPTY_CONDITION;
        if (typeof name !== 'string')
            return name;
        const special = name.startsWith('item:') ? `item:${toID(name.slice(5))}` :
            name.startsWith('ability:') ? `ability:${toID(name.slice(8))}` :
                name.startsWith('move:') ? `move:${toID(name.slice(5))}` : undefined;
        return this.getByID(special || toID(name));
    }
    getByID(id) {
        if (!id)
            return EMPTY_CONDITION;
        let condition = this.conditionCache.get(id);
        if (condition)
            return condition;
        let found;
        if (id.startsWith('item:')) {
            const item = this.dex.items.getByID(id.slice(5));
            condition = item;
        }
        else if (id.startsWith('ability:')) {
            const ability = this.dex.abilities.getByID(id.slice(8));
            condition = ability;
        }
        else if (id.startsWith('move:')) {
            const move = this.dex.moves.getByID(id.slice(5));
            condition = move;
        }
        else if (this.dex.data.Rulesets.hasOwnProperty(id)) {
            condition = this.dex.formats.get(id);
            // formats can't be frozen if they don't have a ruleTable
            this.conditionCache.set(id, condition);
            return condition;
        }
        else if (this.dex.data.Conditions.hasOwnProperty(id)) {
            condition = new Condition({ name: id, ...this.dex.data.Conditions[id] });
        }
        else if ((this.dex.data.Moves.hasOwnProperty(id) && (found = this.dex.data.Moves[id]).condition) ||
            (this.dex.data.Abilities.hasOwnProperty(id) && (found = this.dex.data.Abilities[id]).condition) ||
            (this.dex.data.Items.hasOwnProperty(id) && (found = this.dex.data.Items[id]).condition)) {
            condition = new Condition({ name: found.name || id, ...found.condition });
        }
        else if (id === 'recoil') {
            condition = new Condition({ name: 'Recoil', effectType: 'Recoil' });
        }
        else if (id === 'drain') {
            condition = new Condition({ name: 'Drain', effectType: 'Drain' });
        }
        else {
            condition = new Condition({ name: id, exists: false });
        }
        this.conditionCache.set(id, condition);
        return condition;
    }
}
//# sourceMappingURL=dex-conditions.mjs.map