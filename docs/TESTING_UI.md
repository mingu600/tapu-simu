# Tapu Simu Testing UI

A comprehensive web-based testing interface for the tapu-simu Pokemon battle simulator engine.

## Overview

The Testing UI provides an intuitive interface for testing and validating tapu-simu's battle mechanics. It allows developers and testers to easily create battle scenarios, select moves, and visualize the engine's instruction generation process with real-time feedback.

## Features

### ðŸ—ï¸ Battle State Builder
- **Easy Pokemon Creation**: Auto-populated defaults from PS data when available
- **Species Selection**: Choose from available Pokemon species
- **Quick Add Buttons**: Fast Pokemon addition with preset suggestions  
- **Preset Teams**: Load pre-configured basic and competitive teams
- **Team Management**: Add/remove Pokemon with visual feedback

### âš”ï¸ Move Selection Interface
- **Format-Aware Targeting**: Automatic target resolution based on move types
- **Move Selection**: Choose from each Pokemon's available moves
- **Priority Preview**: See move priorities and categories
- **Real-time Validation**: Invalid moves are highlighted

### ðŸ“Š Instruction Visualization
- **Diff-Style Display**: See generated instructions in a clear format
- **Probability Branches**: View critical hit and accuracy variations
- **Affected Positions**: Highlighted positions impacted by each instruction
- **Step-by-Step Execution**: Detailed instruction breakdown

### ðŸŽ® Real-time Engine Integration
- **Direct API Calls**: All results generated by the actual tapu-simu engine
- **State Management**: Battle state updates in real-time
- **Error Handling**: Graceful handling of engine errors
- **Format Support**: Singles, Doubles, VGC formats supported

## Architecture

### Backend (Rust)
- **Web Server**: Axum-based REST API with WebSocket support
- **Engine Bridge**: Direct integration with tapu-simu engine
- **Pokemon Builder**: Automated Pokemon creation from PS data
- **Session Management**: Battle session tracking and state management

```rust
// Core integration with engine
use crate::engine::GenerationXInstructionGenerator;

pub struct EngineBridge {
    format: BattleFormat,
}

impl EngineBridge {
    pub fn generate_instructions(
        &self,
        state: &mut State,
        side_one_choice: &UIMoveChoice,
        side_two_choice: &UIMoveChoice,
    ) -> InstructionGenerationResponse {
        let generator = self.get_generator();
        let instructions = generator.generate_instructions(state, &choice_one, &choice_two);
        // Convert to UI format...
    }
}
```

### Frontend (React + TypeScript)
- **Component-Based**: Modular React components for each feature
- **TypeScript**: Full type safety with engine API types
- **Modern UI**: Clean, responsive design with Pokemon-themed styling
- **Real-time Updates**: Live battle state synchronization

```typescript
interface BattleState {
  format: BattleFormat
  side_one: BattleSide
  side_two: BattleSide
  weather: string
  terrain: string
  turn: number
}
```

## Quick Start

### 1. Start the Backend Server

```bash
# From the tapu-simu root directory
cargo run --bin ui-server -- --port 3001
```

### 2. Access the Interface

**Option A: Simple HTML Interface (Immediate)**
```bash
open http://localhost:3001
```

**Option B: Full React Development Interface**
```bash
cd ui
npm install
npm run dev
# Then open http://localhost:3000
```

### 3. Create Your First Battle

1. **Build Teams**: Use the Team Builder to add Pokemon to both sides
2. **Create Battle**: Click "Create Battle" to start a battle session
3. **Select Moves**: Choose moves for both Pokemon
4. **Generate Instructions**: Click "Generate Instructions" to see engine output
5. **Analyze Results**: View the instruction breakdown and state changes

## API Reference

### Pokemon Management

#### List Available Pokemon
```http
GET /api/pokemon
```
Returns array of available Pokemon species names.

#### Create Pokemon
```http
POST /api/pokemon/create
Content-Type: application/json

{
  "species": "Pikachu",
  "level": 50
}
```
Creates a Pokemon with default stats and moves.

#### Get Pokemon Details
```http
GET /api/pokemon/{species}
```
Returns detailed Pokemon information including stats, moves, and abilities.

#### Get Pokemon Moves
```http
GET /api/pokemon/{species}/moves
```
Returns list of moves the Pokemon can learn.

### Battle Management

#### Create Battle Session
```http
POST /api/battles
Content-Type: application/json

{
  "format": {
    "name": "Singles",
    "format_type": "Singles",
    "generation": "Gen9",
    "active_pokemon_count": 1
  },
  "side_one": {
    "pokemon": [...],
    "active_pokemon_indices": [0],
    "side_conditions": {}
  },
  "side_two": {
    "pokemon": [...],
    "active_pokemon_indices": [0], 
    "side_conditions": {}
  }
}
```

#### Generate Instructions
```http
POST /api/battles/{session_id}/instructions
Content-Type: application/json

{
  "side_one_choice": {
    "choice_type": "move",
    "move_index": 0,
    "target_positions": [{"side": "two", "slot": 0}]
  },
  "side_two_choice": {
    "choice_type": "move",
    "move_index": 0, 
    "target_positions": [{"side": "one", "slot": 0}]
  }
}
```

### Data Endpoints

```http
GET /api/moves                    # List all moves
GET /api/moves/{name}             # Get move details
GET /api/items                    # List all items
GET /api/presets/pokemon          # Get suggested Pokemon
GET /api/presets/teams/{name}     # Load preset teams
```

## Usage Examples

### Testing Basic Damage Calculation

```typescript
// Create two Pokemon with basic attack moves
const pikachu = await createPokemon("Pikachu", 50);
const charizard = await createPokemon("Charizard", 50);

// Set up battle
const battle = await createBattle({
  format: "Singles",
  side_one: [pikachu],
  side_two: [charizard]
});

// Test Tackle vs Tackle
const instructions = await generateInstructions(battle.sessionId, {
  side_one_choice: { choice_type: "move", move_index: 0 }, // Tackle
  side_two_choice: { choice_type: "move", move_index: 0 }  // Tackle
});

// Analyze damage calculations and speed order
console.log(instructions);
```

### Testing Status Effects

```typescript
// Test Thunder Wave paralysis
const instructions = await generateInstructions(battle.sessionId, {
  side_one_choice: { 
    choice_type: "move", 
    move_index: 1,  // Thunder Wave
    target_positions: [{ side: "two", slot: 0 }]
  },
  side_two_choice: { choice_type: "move", move_index: 0 }
});

// Check for ApplyStatus instructions
const statusInstructions = instructions[0].instructions.filter(
  i => i.instruction_type === "ApplyStatus"
);
```

### Testing Multi-Format Battles

```typescript
// Create Doubles battle
const doublesBattle = await createBattle({
  format: {
    name: "Doubles", 
    format_type: "Doubles",
    generation: "Gen9",
    active_pokemon_count: 2
  },
  side_one: [pokemon1, pokemon2],
  side_two: [pokemon3, pokemon4]
});

// Test spread moves and targeting
const instructions = await generateInstructions(doublesBattle.sessionId, {
  side_one_choice: {
    choice_type: "move",
    move_index: 0, // Earthquake (hits all adjacent)
    target_positions: [] // Auto-targeting
  }
});
```

## Development Guidelines

### Adding New Features

1. **Backend Extensions**: Add new endpoints in `src/ui/server.rs`
2. **Engine Integration**: Extend `EngineBridge` in `src/ui/bridge.rs`
3. **Frontend Components**: Add React components in `ui/src/components/`
4. **Type Definitions**: Update types in `ui/src/types.ts`

### Testing Scenarios

The UI is designed to test these battle scenarios:

- **Basic Attacks**: Damage calculation, type effectiveness, STAB
- **Status Moves**: Paralysis, burn, sleep, stat boosts/drops
- **Weather/Terrain**: Field condition effects on moves and Pokemon
- **Complex Mechanics**: Abilities, items, form changes, Terastallization
- **Multi-Target**: Doubles/VGC spread moves and redirection
- **Priority**: Move order calculation with priority and speed
- **Critical Hits**: Probability branching for damage ranges

### Engine Integration Points

The UI directly integrates with these engine components:

```rust
// Core engine integration
use crate::engine::GenerationXInstructionGenerator;
use crate::instruction::{StateInstructions, Instruction};
use crate::state::State;
use crate::move_choice::MoveChoice;
use crate::battle_format::BattleFormat;
```

All instruction generation goes through the real engine:
- `GenerationXInstructionGenerator::generate_instructions()`
- `State::apply_instructions()`
- Format-aware targeting via `PSAutoTargetingEngine`
- Doubles mechanics via `DoublesSpecificMechanics`

## Configuration

### Server Configuration

```rust
// In src/bin/ui-server.rs
#[derive(Parser)]
struct Args {
    #[arg(short, long, default_value_t = 3000)]
    port: u16,
}
```

### Frontend Configuration

```typescript
// In ui/vite.config.ts
export default defineConfig({
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true,
      }
    }
  }
})
```

## Troubleshooting

### Common Issues

1. **Server Won't Start**
   - Check port availability: `lsof -i :3001`
   - Verify dependencies: `cargo check --bin ui-server`

2. **Pokemon Data Missing**
   - The UI gracefully falls back to default Pokemon when PS data is unavailable
   - Check data files in `data/ps-extracted/`

3. **Instructions Not Generating**
   - Verify both Pokemon have valid moves
   - Check move targeting is appropriate for format
   - Review server logs for engine errors

4. **Frontend Build Issues**
   - Ensure Node.js version compatibility
   - Clear node_modules and reinstall: `rm -rf node_modules && npm install`

### Debug Mode

Enable debug logging:
```bash
RUST_LOG=debug cargo run --bin ui-server
```

## Contributing

When adding new features to the Testing UI:

1. **Follow CLAUDE.md Guidelines**: Maintain format-awareness and position-based targeting
2. **Test Multi-Format**: Ensure features work in Singles, Doubles, and VGC
3. **Engine Integration**: Always use real engine calls, never mock data
4. **Type Safety**: Maintain TypeScript compatibility
5. **Documentation**: Update this file with new features

The Testing UI is a critical tool for validating tapu-simu's battle mechanics and should accurately reflect the engine's capabilities across all supported formats.